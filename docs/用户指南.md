# æ¹¿åœ°é«˜å…‰è°±åˆ†ç±»ç³»ç»Ÿç”¨æˆ·æŒ‡å—
## Wetland Hyperspectral Classification System - User Guide

### ğŸ“– ç›®å½•

1. [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
2. [ç³»ç»Ÿå®‰è£…](#ç³»ç»Ÿå®‰è£…)
3. [åŸºç¡€æ“ä½œ](#åŸºç¡€æ“ä½œ)
4. [é«˜çº§åŠŸèƒ½](#é«˜çº§åŠŸèƒ½)
5. [é…ç½®ç®¡ç†](#é…ç½®ç®¡ç†)
6. [æ•°æ®å¤„ç†æµç¨‹](#æ•°æ®å¤„ç†æµç¨‹)
7. [æ¨¡å‹è®­ç»ƒä¸è¯„ä¼°](#æ¨¡å‹è®­ç»ƒä¸è¯„ä¼°)
8. [ç»“æœåˆ†æä¸å¯è§†åŒ–](#ç»“æœåˆ†æä¸å¯è§†åŒ–)
9. [å¸¸è§é—®é¢˜è§£ç­”](#å¸¸è§é—®é¢˜è§£ç­”)
10. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## ğŸš€ å¿«é€Ÿå¼€å§‹

### 30ç§’å¿«é€Ÿä½“éªŒ

```bash
# 1. å…‹éš†é¡¹ç›®
git clone https://github.com/yourusername/wetland-hyperspectral-classification.git
cd wetland-hyperspectral-classification

# 2. å®‰è£…ç¯å¢ƒ
conda create -n wetland python=3.9
conda activate wetland
pip install -r requirements.txt

# 3. è¿è¡Œæ¼”ç¤º
python examples/åŸºç¡€åˆ†ç±»ç¤ºä¾‹.py
```

### 5åˆ†é’Ÿå®Œæ•´æµç¨‹

```python
from wetland_classification import Pipeline
from wetland_classification.config import Config

# åŠ è½½é»˜è®¤é…ç½®
config = Config.from_default()

# åˆ›å»ºå¤„ç†æµæ°´çº¿
pipeline = Pipeline(config)

# è¿è¡Œæ¼”ç¤ºæ•°æ®
results = pipeline.run_demo()
print(f"åˆ†ç±»å®Œæˆ! ç²¾åº¦: {results['accuracy']:.3f}")
```

---

## âš™ï¸ ç³»ç»Ÿå®‰è£…

### ç³»ç»Ÿè¦æ±‚

| ç»„ä»¶ | æœ€ä½è¦æ±‚ | æ¨èé…ç½® |
|------|----------|----------|
| **æ“ä½œç³»ç»Ÿ** | Ubuntu 18.04+ / Windows 10+ | Ubuntu 20.04 LTS |
| **Python** | 3.8+ | 3.9+ |
| **å†…å­˜** | 8GB | 32GB+ |
| **å­˜å‚¨** | 20GB | 100GB+ SSD |
| **GPU** | å¯é€‰ | NVIDIA RTX 3080+ |

### è¯¦ç»†å®‰è£…æ­¥éª¤

#### æ­¥éª¤1: ç¯å¢ƒå‡†å¤‡

```bash
# æ›´æ–°ç³»ç»Ÿ (Ubuntu)
sudo apt update && sudo apt upgrade -y

# å®‰è£…åŸºç¡€ä¾èµ–
sudo apt install -y build-essential cmake git
sudo apt install -y libgdal-dev gdal-bin
sudo apt install -y python3-dev python3-pip
```

#### æ­¥éª¤2: Pythonç¯å¢ƒ

```bash
# å®‰è£…Miniconda (æ¨è)
wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
bash Miniconda3-latest-Linux-x86_64.sh

# åˆ›å»ºä¸“ç”¨ç¯å¢ƒ
conda create -n wetland python=3.9 -y
conda activate wetland

# å®‰è£…GDAL
conda install -c conda-forge gdal -y
```

#### æ­¥éª¤3: æ·±åº¦å­¦ä¹ æ¡†æ¶

```bash
# CPUç‰ˆæœ¬
pip install torch torchvision torchaudio

# GPUç‰ˆæœ¬ (CUDA 11.8)
pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118

# éªŒè¯å®‰è£…
python -c "import torch; print(f'PyTorch: {torch.__version__}')"
python -c "import torch; print(f'CUDA available: {torch.cuda.is_available()}')"
```

#### æ­¥éª¤4: é¡¹ç›®å®‰è£…

```bash
# å…‹éš†é¡¹ç›®
git clone https://github.com/yourusername/wetland-hyperspectral-classification.git
cd wetland-hyperspectral-classification

# å®‰è£…ä¾èµ–
pip install -r requirements.txt

# å¼€å‘æ¨¡å¼å®‰è£…
pip install -e .

# éªŒè¯å®‰è£…
python -c "import wetland_classification; print('å®‰è£…æˆåŠŸ!')"
```

---

## ğŸ”§ åŸºç¡€æ“ä½œ

### æ•°æ®åŠ è½½

```python
from wetland_classification.data import DataLoader

# åˆ›å»ºæ•°æ®åŠ è½½å™¨
loader = DataLoader()

# åŠ è½½é«˜å…‰è°±æ•°æ®
hyperspectral_data = loader.load_hyperspectral('path/to/data.tif')

# åŠ è½½åœ°é¢çœŸå®æ•°æ®
ground_truth = loader.load_ground_truth('path/to/labels.shp')

# æ‰¹é‡åŠ è½½
data_dict = loader.load_scene_data('path/to/scene_directory/')
```

### æ•°æ®é¢„å¤„ç†

```python
from wetland_classification.preprocessing import Preprocessor

# åˆ›å»ºé¢„å¤„ç†å™¨
preprocessor = Preprocessor()

# åŸºç¡€é¢„å¤„ç†æµç¨‹
processed_data = preprocessor.process_all(
    hyperspectral_data,
    steps=['radiometric', 'atmospheric', 'geometric', 'noise_reduction']
)

# è‡ªå®šä¹‰é¢„å¤„ç†
processed_data = preprocessor.radiometric_calibration(hyperspectral_data)
processed_data = preprocessor.atmospheric_correction(processed_data)
```

### ç‰¹å¾æå–

```python
from wetland_classification.features import FeatureExtractor

# åˆ›å»ºç‰¹å¾æå–å™¨
extractor = FeatureExtractor()

# æå–æ‰€æœ‰ç‰¹å¾
features = extractor.extract_all(processed_data)

# æå–ç‰¹å®šç‰¹å¾
spectral_features = extractor.extract_spectral_features(processed_data)
vegetation_indices = extractor.extract_vegetation_indices(processed_data)
texture_features = extractor.extract_texture_features(processed_data)
```

### æ¨¡å‹è®­ç»ƒ

```python
from wetland_classification.classification import Classifier

# åˆ›å»ºåˆ†ç±»å™¨
classifier = Classifier(model_type='hybrid_cnn')

# è®­ç»ƒæ¨¡å‹
model = classifier.train(
    X_train=features,
    y_train=labels,
    validation_split=0.2,
    epochs=100,
    batch_size=32
)

# ä¿å­˜æ¨¡å‹
classifier.save_model('models/my_model.pkl')
```

### é¢„æµ‹åˆ†ç±»

```python
# åŠ è½½è®­ç»ƒå¥½çš„æ¨¡å‹
classifier = Classifier.load_model('models/my_model.pkl')

# é¢„æµ‹
predictions = classifier.predict(test_features)

# æ‰¹é‡é¢„æµ‹
results = classifier.predict_scene('path/to/test_scene.tif')
```

---

## ğŸ¯ é«˜çº§åŠŸèƒ½

### é›†æˆå­¦ä¹ 

```python
from wetland_classification.classification import EnsembleClassifier

# åˆ›å»ºé›†æˆåˆ†ç±»å™¨
ensemble = EnsembleClassifier([
    ('svm', 'svm'),
    ('rf', 'random_forest'),
    ('xgb', 'xgboost'),
    ('cnn', 'hybrid_cnn')
])

# è®­ç»ƒé›†æˆæ¨¡å‹
ensemble.fit(X_train, y_train)

# é¢„æµ‹
predictions = ensemble.predict(X_test)
confidence = ensemble.predict_proba(X_test)
```

### è¶…å‚æ•°ä¼˜åŒ–

```python
from wetland_classification.optimization import HyperparameterOptimizer

# åˆ›å»ºä¼˜åŒ–å™¨
optimizer = HyperparameterOptimizer(
    model_type='hybrid_cnn',
    optimization_method='bayesian'
)

# å®šä¹‰æœç´¢ç©ºé—´
param_space = {
    'learning_rate': (0.0001, 0.01),
    'batch_size': [16, 32, 64, 128],
    'dropout_rate': (0.1, 0.5),
    'filters': [32, 64, 128, 256]
}

# æ‰§è¡Œä¼˜åŒ–
best_params = optimizer.optimize(
    X_train, y_train,
    param_space=param_space,
    n_trials=50,
    cv_folds=5
)
```

### ä¸ç¡®å®šæ€§åˆ†æ

```python
from wetland_classification.evaluation import UncertaintyAnalyzer

# åˆ›å»ºä¸ç¡®å®šæ€§åˆ†æå™¨
analyzer = UncertaintyAnalyzer()

# Monte Carlo Dropout
mc_predictions = analyzer.monte_carlo_dropout(
    model, X_test, n_samples=100
)

# è®¡ç®—ä¸ç¡®å®šæ€§æŒ‡æ ‡
uncertainty_metrics = analyzer.compute_uncertainty_metrics(mc_predictions)

# å¯è§†åŒ–ä¸ç¡®å®šæ€§
analyzer.plot_uncertainty_map(uncertainty_metrics)
```

### æ—¶åºåˆ†æ

```python
from wetland_classification.temporal import TemporalAnalyzer

# åˆ›å»ºæ—¶åºåˆ†æå™¨
temporal = TemporalAnalyzer()

# åŠ è½½å¤šæ—¶ç›¸æ•°æ®
temporal_data = temporal.load_time_series('path/to/temporal_data/')

# å˜åŒ–æ£€æµ‹
change_map = temporal.detect_changes(
    image_t1='2023_scene.tif',
    image_t2='2024_scene.tif',
    method='change_vector_analysis'
)

# è¶‹åŠ¿åˆ†æ
trends = temporal.analyze_trends(temporal_data, method='mann_kendall')
```

---

## âš™ï¸ é…ç½®ç®¡ç†

### é…ç½®æ–‡ä»¶ç»“æ„

```yaml
# config/config.yaml
data:
  input_path: "data/raw/"
  output_path: "output/"
  file_format: "tif"
  
preprocessing:
  radiometric_calibration: true
  atmospheric_correction: "FLAASH"
  geometric_correction: true
  noise_reduction: "MNF"
  
features:
  spectral_features: true
  vegetation_indices: ["NDVI", "NDWI", "EVI", "SAVI"]
  texture_features: ["GLCM"]
  spatial_features: true
  
classification:
  model_type: "hybrid_cnn"
  training_ratio: 0.7
  validation_ratio: 0.15
  test_ratio: 0.15
  
evaluation:
  metrics: ["accuracy", "kappa", "f1_score"]
  cross_validation: 5
  confidence_interval: 0.95
```

### é…ç½®æ–‡ä»¶ä½¿ç”¨

```python
from wetland_classification.config import Config

# ä»æ–‡ä»¶åŠ è½½é…ç½®
config = Config.from_file('config/config.yaml')

# ä»å­—å…¸åˆ›å»ºé…ç½®
config = Config.from_dict({
    'data': {'input_path': 'data/'},
    'preprocessing': {'atmospheric_correction': 'FLAASH'}
})

# ä¿®æ”¹é…ç½®
config.set('classification.model_type', 'svm')
config.set('features.vegetation_indices', ['NDVI', 'EVI'])

# ä¿å­˜é…ç½®
config.save('config/my_config.yaml')

# éªŒè¯é…ç½®
config.validate()
```

### å¤šç¯å¢ƒé…ç½®

```python
# å¼€å‘ç¯å¢ƒ
config_dev = Config.from_file('config/dev.yaml')

# ç”Ÿäº§ç¯å¢ƒ
config_prod = Config.from_file('config/prod.yaml')

# æµ‹è¯•ç¯å¢ƒ
config_test = Config.from_file('config/test.yaml')

# ç¯å¢ƒè‡ªåŠ¨åˆ‡æ¢
import os
env = os.getenv('WETLAND_ENV', 'dev')
config = Config.from_file(f'config/{env}.yaml')
```

---

## ğŸ”„ æ•°æ®å¤„ç†æµç¨‹

### å®Œæ•´æµç¨‹ç¤ºä¾‹

```python
from wetland_classification import Pipeline

# åˆ›å»ºå®Œæ•´å¤„ç†æµæ°´çº¿
pipeline = Pipeline.from_config('config/config.yaml')

# æ‰§è¡Œå®Œæ•´æµç¨‹
results = pipeline.run(
    input_data='data/raw/scene.tif',
    ground_truth='data/raw/labels.shp',
    output_dir='output/results/'
)

# æŸ¥çœ‹ç»“æœ
print(f"Processing completed!")
print(f"Accuracy: {results['accuracy']:.3f}")
print(f"Kappa: {results['kappa']:.3f}")
print(f"Output files: {results['output_files']}")
```

### åˆ†æ­¥éª¤æ‰§è¡Œ

```python
# æ­¥éª¤1: æ•°æ®åŠ è½½
data = pipeline.load_data('data/raw/scene.tif')

# æ­¥éª¤2: é¢„å¤„ç†
processed = pipeline.preprocess(data)

# æ­¥éª¤3: ç‰¹å¾æå–
features = pipeline.extract_features(processed)

# æ­¥éª¤4: æ¨¡å‹è®­ç»ƒ
model = pipeline.train_model(features, labels)

# æ­¥éª¤5: é¢„æµ‹
predictions = pipeline.predict(model, features)

# æ­¥éª¤6: åå¤„ç†
final_results = pipeline.postprocess(predictions)

# æ­¥éª¤7: è¯„ä¼°
metrics = pipeline.evaluate(final_results, ground_truth)
```

### æ‰¹é‡å¤„ç†

```python
from wetland_classification.batch import BatchProcessor

# åˆ›å»ºæ‰¹é‡å¤„ç†å™¨
batch_processor = BatchProcessor(config)

# æ‰¹é‡å¤„ç†å¤šä¸ªåœºæ™¯
scenes = [
    'data/raw/scene1.tif',
    'data/raw/scene2.tif',
    'data/raw/scene3.tif'
]

results = batch_processor.process_scenes(
    scenes,
    output_dir='output/batch_results/',
    parallel=True,
    n_jobs=4
)
```

---

## ğŸ“Š æ¨¡å‹è®­ç»ƒä¸è¯„ä¼°

### æ¨¡å‹é€‰æ‹©æŒ‡å—

| æ¨¡å‹ç±»å‹ | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ | æ¨èæŒ‡æ•° |
|----------|----------|------|------|----------|
| **SVM** | å°æ•°æ®é›†, å¿«é€ŸåŸå‹ | ç¨³å®š, å¿«é€Ÿ | ç‰¹å¾å·¥ç¨‹éœ€æ±‚é«˜ | â­â­â­ |
| **Random Forest** | ä¸­ç­‰æ•°æ®é›†, ç‰¹å¾é‡è¦æ€§ | æ˜“è§£é‡Š, é²æ£’ | å†…å­˜æ¶ˆè€—å¤§ | â­â­â­â­ |
| **XGBoost** | è¡¨æ ¼æ•°æ®, ç«èµ› | é«˜ç²¾åº¦, è°ƒå‚çµæ´» | å®¹æ˜“è¿‡æ‹Ÿåˆ | â­â­â­â­ |
| **3D-CNN** | å¤§æ•°æ®é›†, ç©ºè°±ç‰¹å¾ | è‡ªåŠ¨ç‰¹å¾æå– | è®¡ç®—å¤æ‚ | â­â­â­â­â­ |
| **HybridSN** | å¤æ‚åœºæ™¯, é«˜ç²¾åº¦ | ç²¾åº¦æœ€é«˜ | è®­ç»ƒæ—¶é—´é•¿ | â­â­â­â­â­ |

### è®­ç»ƒç­–ç•¥

```python
from wetland_classification.training import TrainingStrategy

# åˆ›å»ºè®­ç»ƒç­–ç•¥
strategy = TrainingStrategy(
    early_stopping=True,
    patience=10,
    learning_rate_scheduler='cosine',
    data_augmentation=True,
    class_balancing='weighted'
)

# åº”ç”¨ç­–ç•¥
trainer = strategy.create_trainer(model_type='hybrid_cnn')
model = trainer.fit(X_train, y_train, X_val, y_val)
```

### äº¤å‰éªŒè¯

```python
from wetland_classification.evaluation import CrossValidator

# KæŠ˜äº¤å‰éªŒè¯
cv = CrossValidator(k=5, stratified=True)
cv_results = cv.validate(
    classifier,
    features, labels,
    metrics=['accuracy', 'kappa', 'f1_macro']
)

# ç•™ä¸€ç»„äº¤å‰éªŒè¯ (Leave-One-Group-Out)
logo_cv = CrossValidator(method='logo', groups=site_labels)
logo_results = logo_cv.validate(classifier, features, labels)
```

### æ¨¡å‹æ¯”è¾ƒ

```python
from wetland_classification.comparison import ModelComparison

# åˆ›å»ºæ¨¡å‹æ¯”è¾ƒå™¨
comparison = ModelComparison()

# æ·»åŠ æ¨¡å‹
comparison.add_model('SVM', svm_model)
comparison.add_model('Random Forest', rf_model)
comparison.add_model('HybridSN', hybrid_model)

# æ‰§è¡Œæ¯”è¾ƒ
results = comparison.compare(
    X_test, y_test,
    metrics=['accuracy', 'kappa', 'f1_score'],
    statistical_test='mcnemar'
)

# ç”Ÿæˆæ¯”è¾ƒæŠ¥å‘Š
comparison.generate_report('output/model_comparison.html')
```

---

## ğŸ“ˆ ç»“æœåˆ†æä¸å¯è§†åŒ–

### åˆ†ç±»ç»“æœå¯è§†åŒ–

```python
from wetland_classification.visualization import ResultVisualizer

# åˆ›å»ºå¯è§†åŒ–å™¨
visualizer = ResultVisualizer()

# åˆ†ç±»ç»“æœå›¾
visualizer.plot_classification_map(
    predictions,
    title='Wetland Classification Results',
    save_path='output/classification_map.png'
)

# ç±»åˆ«åˆ†å¸ƒå›¾
visualizer.plot_class_distribution(
    predictions,
    class_names=wetland_classes,
    save_path='output/class_distribution.png'
)

# ç½®ä¿¡åº¦å›¾
visualizer.plot_confidence_map(
    confidence_scores,
    save_path='output/confidence_map.png'
)
```

### ç²¾åº¦è¯„ä¼°å¯è§†åŒ–

```python
# æ··æ·†çŸ©é˜µ
visualizer.plot_confusion_matrix(
    y_true, y_pred,
    class_names=wetland_classes,
    normalize=True,
    save_path='output/confusion_matrix.png'
)

# ROCæ›²çº¿
visualizer.plot_roc_curves(
    y_true, y_scores,
    class_names=wetland_classes,
    save_path='output/roc_curves.png'
)

# ç²¾åº¦-å¬å›ç‡æ›²çº¿
visualizer.plot_precision_recall_curves(
    y_true, y_scores,
    save_path='output/pr_curves.png'
)
```

### ç‰¹å¾é‡è¦æ€§åˆ†æ

```python
# ç‰¹å¾é‡è¦æ€§å›¾
visualizer.plot_feature_importance(
    feature_importance,
    feature_names=feature_names,
    top_k=20,
    save_path='output/feature_importance.png'
)

# å…‰è°±ç‰¹å¾å›¾
visualizer.plot_spectral_signatures(
    spectral_data,
    class_labels=labels,
    wavelengths=wavelengths,
    save_path='output/spectral_signatures.png'
)
```

### æ™¯è§‚åˆ†æå¯è§†åŒ–

```python
from wetland_classification.landscape import LandscapeVisualizer

# æ™¯è§‚æŒ‡æ•°å¯è§†åŒ–
landscape_viz = LandscapeVisualizer()

# æ™¯è§‚æ ¼å±€å›¾
landscape_viz.plot_landscape_patterns(
    classification_map,
    save_path='output/landscape_patterns.png'
)

# è¿é€šæ€§åˆ†æ
landscape_viz.plot_connectivity_analysis(
    classification_map,
    save_path='output/connectivity_analysis.png'
)
```

---

## â“ å¸¸è§é—®é¢˜è§£ç­”

### å®‰è£…é—®é¢˜

**Q: GDALå®‰è£…å¤±è´¥æ€ä¹ˆåŠï¼Ÿ**
```bash
# Ubuntuè§£å†³æ–¹æ¡ˆ
sudo apt install libgdal-dev gdal-bin
export CPLUS_INCLUDE_PATH=/usr/include/gdal
export C_INCLUDE_PATH=/usr/include/gdal
pip install GDAL==$(gdal-config --version) --global-option=build_ext --global-option="-I/usr/include/gdal"

# condaè§£å†³æ–¹æ¡ˆ (æ¨è)
conda install -c conda-forge gdal
```

**Q: PyTorch GPUç‰ˆæœ¬æ— æ³•ä½¿ç”¨ï¼Ÿ**
```python
# æ£€æŸ¥CUDAç‰ˆæœ¬
import torch
print(f"CUDA available: {torch.cuda.is_available()}")
print(f"CUDA version: {torch.version.cuda}")

# é‡æ–°å®‰è£…å¯¹åº”ç‰ˆæœ¬
pip uninstall torch torchvision torchaudio
pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
```

### æ•°æ®é—®é¢˜

**Q: é«˜å…‰è°±æ•°æ®æ ¼å¼ä¸æ”¯æŒï¼Ÿ**
```python
# è½¬æ¢ä¸ºæ”¯æŒçš„æ ¼å¼
from wetland_classification.utils import DataConverter

converter = DataConverter()
converted_data = converter.convert_to_geotiff('input.bil', 'output.tif')
```

**Q: å†…å­˜ä¸è¶³æ€ä¹ˆåŠï¼Ÿ**
```python
# ä½¿ç”¨æ•°æ®åˆ†å—å¤„ç†
from wetland_classification.utils import TileProcessor

processor = TileProcessor(tile_size=512, overlap=64)
results = processor.process_large_image('large_scene.tif')
```

### æ¨¡å‹é—®é¢˜

**Q: è®­ç»ƒç²¾åº¦ä¸é«˜ï¼Ÿ**
```python
# 1. å¢åŠ è®­ç»ƒæ•°æ®
# 2. è°ƒæ•´æ¨¡å‹å‚æ•°
# 3. ä½¿ç”¨æ•°æ®å¢å¼º
# 4. å°è¯•ä¸åŒæ¨¡å‹

# è¯Šæ–­å·¥å…·
from wetland_classification.diagnosis import ModelDiagnostics

diagnostics = ModelDiagnostics()
diagnostics.analyze_model_performance(model, X_train, y_train, X_val, y_val)
```

**Q: æ¨¡å‹é¢„æµ‹æ—¶é—´å¤ªé•¿ï¼Ÿ**
```python
# æ¨¡å‹ä¼˜åŒ–
from wetland_classification.optimization import ModelOptimizer

optimizer = ModelOptimizer()
optimized_model = optimizer.optimize_for_inference(model)

# æ‰¹é‡é¢„æµ‹
predictions = optimized_model.predict_batch(test_data, batch_size=64)
```

---

## ğŸ’¡ æœ€ä½³å®è·µ

### æ•°æ®å‡†å¤‡æœ€ä½³å®è·µ

1. **æ•°æ®è´¨é‡æ£€æŸ¥**
```python
from wetland_classification.quality import DataQualityChecker

checker = DataQualityChecker()
quality_report = checker.check_data_quality('data/raw/scene.tif')
print(quality_report.summary())
```

2. **æ ·æœ¬å¹³è¡¡æ€§æ£€æŸ¥**
```python
from wetland_classification.utils import check_class_balance

balance_report = check_class_balance(labels)
if balance_report.is_imbalanced:
    # ä½¿ç”¨ç±»åˆ«æƒé‡æˆ–é‡‡æ ·ç­–ç•¥
    pass
```

### æ¨¡å‹è®­ç»ƒæœ€ä½³å®è·µ

1. **ä½¿ç”¨éªŒè¯é›†è¿›è¡Œæ—©åœ**
```python
from wetland_classification.callbacks import EarlyStopping

early_stopping = EarlyStopping(
    monitor='val_accuracy',
    patience=10,
    restore_best_weights=True
)
```

2. **å­¦ä¹ ç‡è°ƒåº¦**
```python
from wetland_classification.callbacks import LearningRateScheduler

lr_scheduler = LearningRateScheduler(
    schedule='cosine_annealing',
    initial_lr=0.001,
    min_lr=1e-6
)
```

3. **æ¨¡å‹é›†æˆ**
```python
# ä½¿ç”¨ä¸åŒçš„éšæœºç§å­è®­ç»ƒå¤šä¸ªæ¨¡å‹
models = []
for seed in [42, 123, 456, 789, 999]:
    model = train_model_with_seed(seed)
    models.append(model)

# é›†æˆé¢„æµ‹
ensemble_pred = ensemble_predict(models, X_test)
```

### ç»“æœéªŒè¯æœ€ä½³å®è·µ

1. **å¤šæŒ‡æ ‡è¯„ä¼°**
```python
from wetland_classification.metrics import comprehensive_evaluation

metrics = comprehensive_evaluation(
    y_true, y_pred,
    include_per_class=True,
    include_confusion_matrix=True,
    include_classification_report=True
)
```

2. **ç»Ÿè®¡æ˜¾è‘—æ€§æ£€éªŒ**
```python
from wetland_classification.statistics import significance_test

p_value = significance_test(
    model1_accuracy, model2_accuracy,
    test='paired_t_test'
)
```

3. **é”™è¯¯åˆ†æ**
```python
from wetland_classification.analysis import ErrorAnalyzer

analyzer = ErrorAnalyzer()
error_patterns = analyzer.analyze_errors(
    y_true, y_pred, features,
    visualize=True
)
```

### éƒ¨ç½²æœ€ä½³å®è·µ

1. **æ¨¡å‹ç‰ˆæœ¬ç®¡ç†**
```python
from wetland_classification.versioning import ModelVersioning

versioning = ModelVersioning()
versioning.save_model_version(
    model, 
    version='v1.0.0',
    metadata={'accuracy': 0.95, 'training_date': '2024-06-30'}
)
```

2. **æ¨¡å‹ç›‘æ§**
```python
from wetland_classification.monitoring import ModelMonitor

monitor = ModelMonitor()
monitor.track_model_performance(
    model, 
    new_data,
    alert_threshold=0.05  # æ€§èƒ½ä¸‹é™5%æ—¶å‘Šè­¦
)
```

---

## ğŸ“ æŠ€æœ¯æ”¯æŒ

### è·å–å¸®åŠ©

- ğŸ“§ **é‚®ç®±æ”¯æŒ**: user-support@example.com
- ğŸ”— **åœ¨çº¿æ–‡æ¡£**: https://docs.example.com
- ğŸ’¬ **è®¨è®ºè®ºå›**: https://github.com/yourusername/wetland-hyperspectral-classification/discussions
- ğŸ› **é—®é¢˜æŠ¥å‘Š**: https://github.com/yourusername/wetland-hyperspectral-classification/issues

### ç¤¾åŒºèµ„æº

- ğŸ“š **æ•™ç¨‹è§†é¢‘**: YouTubeé¢‘é“
- ğŸ“– **åšå®¢æ–‡ç« **: å®˜æ–¹åšå®¢
- ğŸ‘¥ **ç”¨æˆ·ç¤¾åŒº**: QQç¾¤/å¾®ä¿¡ç¾¤
- ğŸ“ **åœ¨çº¿è¯¾ç¨‹**: åœ¨çº¿åŸ¹è®­å¹³å°

---

*æœ¬ç”¨æˆ·æŒ‡å—æŒç»­æ›´æ–°ä¸­ï¼Œæœ€åæ›´æ–°æ—¶é—´: 2024å¹´6æœˆ30æ—¥*