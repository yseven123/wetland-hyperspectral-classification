{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 湿地高光谱特征工程\n",
    "\n",
    "## 概述\n",
    "本notebook展示了湿地高光谱遥感数据的特征工程过程，包括：\n",
    "- 光谱特征提取\n",
    "- 植被指数计算\n",
    "- 纹理特征分析\n",
    "- 空间特征提取\n",
    "- 特征选择与降维\n",
    "- 特征重要性分析\n",
    "\n",
    "特征工程是高光谱分类成功的关键步骤，通过提取有效特征可以显著提高分类精度。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 导入必要的库\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from pathlib import Path\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "# 图像处理和光谱分析\n",
    "import cv2\n",
    "from skimage import filters, feature, segmentation\n",
    "from skimage.morphology import disk\n",
    "import spectral as spy\n",
    "import rasterio\n",
    "\n",
    "# 机器学习\n",
    "from sklearn.decomposition import PCA, FastICA, NMF\n",
    "from sklearn.feature_selection import (\n",
    "    SelectKBest, f_classif, mutual_info_classif,\n",
    "    RFE, SelectFromModel\n",
    ")\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.preprocessing import StandardScaler, MinMaxScaler\n",
    "from sklearn.manifold import TSNE\n",
    "from sklearn.cluster import KMeans\n",
    "\n",
    "# 科学计算\n",
    "from scipy import ndimage, signal\n",
    "from scipy.stats import skew, kurtosis\n",
    "\n",
    "# 自定义模块\n",
    "import sys\n",
    "sys.path.append('../src')\n",
    "from wetland_classification.features import (\n",
    "    SpectralFeatureExtractor,\n",
    "    VegetationIndices,\n",
    "    TextureAnalyzer, \n",
    "    SpatialFeatureExtractor\n",
    ")\n",
    "from wetland_classification.data import DataLoader\n",
    "from wetland_classification.utils import visualization, logger\n",
    "\n",
    "# 设置绘图样式\n",
    "plt.style.use('seaborn-v0_8')\n",
    "sns.set_palette(\"husl\")\n",
    "\n",
    "# 配置日志\n",
    "logger = logger.setup_logger('feature_engineering', level='INFO')\n",
    "\n",
    "print(\"特征工程环境初始化完成！\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. 数据加载"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 加载预处理后的数据\n",
    "data_dir = Path('../data/processed')\n",
    "output_dir = Path('../data/features')\n",
    "output_dir.mkdir(exist_ok=True)\n",
    "\n",
    "# 数据文件路径\n",
    "hyperspectral_file = data_dir / 'preprocessed_hyperspectral.tif'\n",
    "metadata_file = data_dir / 'preprocessed_metadata.json'\n",
    "ground_truth_file = Path('../data/raw/training_samples.shp')\n",
    "\n",
    "print(f\"高光谱数据: {hyperspectral_file}\")\n",
    "print(f\"元数据: {metadata_file}\")\n",
    "print(f\"训练样本: {ground_truth_file}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 加载数据\n",
    "loader = DataLoader()\n",
    "hyperspectral_data, metadata = loader.load_hyperspectral(str(hyperspectral_file))\n",
    "\n",
    "print(\"数据基本信息:\")\n",
    "print(f\"数据形状: {hyperspectral_data.shape}\")\n",
    "print(f\"数据类型: {hyperspectral_data.dtype}\")\n",
    "print(f\"波段数量: {hyperspectral_data.shape[2]}\")\n",
    "print(f\"数据范围: {hyperspectral_data.min():.4f} - {hyperspectral_data.max():.4f}\")\n",
    "\n",
    "# 获取波长信息\n",
    "wavelengths = metadata.get('wavelengths', np.arange(hyperspectral_data.shape[2]))\n",
    "print(f\"波长范围: {wavelengths[0]:.1f} - {wavelengths[-1]:.1f} nm\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 加载训练样本（如果存在）\n",
    "if ground_truth_file.exists():\n",
    "    import geopandas as gpd\n",
    "    training_samples = gpd.read_file(ground_truth_file)\n",
    "    print(f\"\\n训练样本信息:\")\n",
    "    print(f\"样本数量: {len(training_samples)}\")\n",
    "    print(f\"类别数量: {training_samples['class'].nunique()}\")\n",
    "    print(f\"类别分布:\\n{training_samples['class'].value_counts()}\")\n",
    "else:\n",
    "    print(\"未找到训练样本文件\")\n",
    "    training_samples = None"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. 光谱特征提取"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 创建光谱特征提取器\n",
    "spectral_extractor = SpectralFeatureExtractor(\n",
    "    wavelengths=wavelengths,\n",
    "    feature_types=[\n",
    "        'continuum_removal',\n",
    "        'spectral_derivatives', \n",
    "        'absorption_features',\n",
    "        'spectral_slope',\n",
    "        'spectral_curvature'\n",
    "    ]\n",
    ")\n",
    "\n",
    "print(\"开始提取光谱特征...\")\n",
    "\n",
    "# 提取光谱特征\n",
    "spectral_features = spectral_extractor.extract_features(hyperspectral_data)\n",
    "\n",
    "print(f\"光谱特征提取完成\")\n",
    "print(f\"特征维度: {spectral_features.shape}\")\n",
    "print(f\"特征名称: {spectral_extractor.get_feature_names()}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 可视化光谱特征\n",
    "fig, axes = plt.subplots(2, 3, figsize=(18, 12))\n",
    "\n",
    "# 选择一个典型像素的光谱\n",
    "pixel_x, pixel_y = 150, 200\n",
    "original_spectrum = hyperspectral_data[pixel_x, pixel_y, :]\n",
    "\n",
    "# 原始光谱\n",
    "axes[0, 0].plot(wavelengths, original_spectrum, 'b-', linewidth=2)\n",
    "axes[0, 0].set_title('原始光谱')\n",
    "axes[0, 0].set_xlabel('波长 (nm)')\n",
    "axes[0, 0].set_ylabel('反射率')\n",
    "axes[0, 0].grid(True, alpha=0.3)\n",
    "\n",
    "# 连续统去除\n",
    "continuum_removed = spectral_extractor.continuum_removal(original_spectrum, wavelengths)\n",
    "axes[0, 1].plot(wavelengths, continuum_removed, 'r-', linewidth=2)\n",
    "axes[0, 1].set_title('连续统去除')\n",
    "axes[0, 1].set_xlabel('波长 (nm)')\n",
    "axes[0, 1].set_ylabel('连续统去除反射率')\n",
    "axes[0, 1].grid(True, alpha=0.3)\n",
    "\n",
    "# 一阶导数\n",
    "first_derivative = spectral_extractor.first_derivative(original_spectrum)\n",
    "axes[0, 2].plot(wavelengths[:-1], first_derivative, 'g-', linewidth=2)\n",
    "axes[0, 2].set_title('一阶导数')\n",
    "axes[0, 2].set_xlabel('波长 (nm)')\n",
    "axes[0, 2].set_ylabel('一阶导数')\n",
    "axes[0, 2].grid(True, alpha=0.3)\n",
    "\n",
    "# 二阶导数\n",
    "second_derivative = spectral_extractor.second_derivative(original_spectrum)\n",
    "axes[1, 0].plot(wavelengths[:-2], second_derivative, 'm-', linewidth=2)\n",
    "axes[1, 0].set_title('二阶导数')\n",
    "axes[1, 0].set_xlabel('波长 (nm)')\n",
    "axes[1, 0].set_ylabel('二阶导数')\n",
    "axes[1, 0].grid(True, alpha=0.3)\n",
    "\n",
    "# 吸收特征深度\n",
    "absorption_depth = spectral_extractor.absorption_depth(original_spectrum, wavelengths)\n",
    "if len(absorption_depth) > 0:\n",
    "    axes[1, 1].bar(range(len(absorption_depth)), absorption_depth, color='orange', alpha=0.7)\n",
    "    axes[1, 1].set_title('吸收特征深度')\n",
    "    axes[1, 1].set_xlabel('吸收特征索引')\n",
    "    axes[1, 1].set_ylabel('深度')\n",
    "    axes[1, 1].grid(True, alpha=0.3)\n",
    "\n",
    "# 光谱斜率\n",
    "red_edge_slope = spectral_extractor.red_edge_slope(original_spectrum, wavelengths)\n",
    "nir_slope = spectral_extractor.nir_slope(original_spectrum, wavelengths)\n",
    "slopes = [red_edge_slope, nir_slope]\n",
    "slope_names = ['Red Edge', 'NIR']\n",
    "axes[1, 2].bar(slope_names, slopes, color=['red', 'darkgreen'], alpha=0.7)\n",
    "axes[1, 2].set_title('光谱斜率')\n",
    "axes[1, 2].set_ylabel('斜率')\n",
    "axes[1, 2].grid(True, alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. 植被指数计算"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 创建植被指数计算器\n",
    "vegetation_indices = VegetationIndices(wavelengths=wavelengths)\n",
    "\n",
    "print(\"开始计算植被指数...\")\n",
    "\n",
    "# 计算常用植被指数\n",
    "vegetation_features = vegetation_indices.calculate_all_indices(hyperspectral_data)\n",
    "\n",
    "print(f\"植被指数计算完成\")\n",
    "print(f\"植被指数数量: {len(vegetation_indices.get_index_names())}\")\n",
    "print(f\"植被指数名称: {vegetation_indices.get_index_names()}\")\n",
    "print(f\"植被特征形状: {vegetation_features.shape}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 可视化主要植被指数\n",
    "fig, axes = plt.subplots(3, 4, figsize=(20, 15))\n",
    "axes = axes.flatten()\n",
    "\n",
    "index_names = vegetation_indices.get_index_names()\n",
    "main_indices = index_names[:12]  # 显示前12个主要指数\n",
    "\n",
    "for i, index_name in enumerate(main_indices):\n",
    "    index_data = vegetation_features[:, :, i]\n",
    "    \n",
    "    # 处理异常值\n",
    "    vmin, vmax = np.percentile(index_data[np.isfinite(index_data)], [2, 98])\n",
    "    \n",
    "    im = axes[i].imshow(index_data, cmap='RdYlGn', vmin=vmin, vmax=vmax)\n",
    "    axes[i].set_title(f'{index_name}', fontsize=10)\n",
    "    axes[i].axis('off')\n",
    "    plt.colorbar(im, ax=axes[i], fraction=0.046, pad=0.04)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 分析植被指数统计特性\n",
    "vegetation_stats = {}\n",
    "for i, index_name in enumerate(index_names):\n",
    "    index_data = vegetation_features[:, :, i]\n",
    "    valid_data = index_data[np.isfinite(index_data)]\n",
    "    \n",
    "    if len(valid_data) > 0:\n",
    "        vegetation_stats[index_name] = {\n",
    "            'mean': np.mean(valid_data),\n",
    "            'std': np.std(valid_data),\n",
    "            'min': np.min(valid_data),\n",
    "            'max': np.max(valid_data),\n",
    "            'skewness': skew(valid_data),\n",
    "            'kurtosis': kurtosis(valid_data)\n",
    "        }\n",
    "\n",
    "# 转换为DataFrame并显示\n",
    "vegetation_stats_df = pd.DataFrame(vegetation_stats).T\n",
    "print(\"植被指数统计特性:\")\n",
    "print(vegetation_stats_df.round(4))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. 纹理特征分析"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 创建纹理分析器\n",
    "texture_analyzer = TextureAnalyzer(\n",
    "    methods=['glcm', 'lbp', 'gabor', 'laws'],\n",
    "    window_sizes=[3, 5, 7],\n",
    "    directions=[0, 45, 90, 135],\n",
    "    distances=[1, 2, 3]\n",
    ")\n",
    "\n",
    "print(\"开始提取纹理特征...\")\n",
    "\n",
    "# 选择几个代表性波段进行纹理分析\n",
    "texture_bands = [20, 60, 120, 180]  # 不同光谱区域的代表性波段\n",
    "texture_features_list = []\n",
    "\n",
    "for band_idx in texture_bands:\n",
    "    band_data = hyperspectral_data[:, :, band_idx]\n",
    "    band_texture = texture_analyzer.extract_texture_features(band_data)\n",
    "    texture_features_list.append(band_texture)\n",
    "\n",
    "# 合并所有纹理特征\n",
    "texture_features = np.concatenate(texture_features_list, axis=2)\n",
    "\n",
    "print(f\"纹理特征提取完成\")\n",
    "print(f\"纹理特征形状: {texture_features.shape}\")\n",
    "print(f\"每个波段纹理特征数: {texture_features_list[0].shape[2]}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 可视化纹理特征\n",
    "fig, axes = plt.subplots(4, 6, figsize=(24, 16))\n",
    "\n",
    "feature_names = texture_analyzer.get_feature_names()\n",
    "features_to_show = feature_names[:24]  # 显示前24个纹理特征\n",
    "\n",
    "for i, feature_name in enumerate(features_to_show):\n",
    "    row, col = i // 6, i % 6\n",
    "    \n",
    "    # 选择第一个波段的纹理特征进行显示\n",
    "    feature_idx = i % texture_features_list[0].shape[2]\n",
    "    feature_data = texture_features_list[0][:, :, feature_idx]\n",
    "    \n",
    "    # 处理异常值\n",
    "    vmin, vmax = np.percentile(feature_data[np.isfinite(feature_data)], [2, 98])\n",
    "    \n",
    "    im = axes[row, col].imshow(feature_data, cmap='viridis', vmin=vmin, vmax=vmax)\n",
    "    axes[row, col].set_title(f'{feature_name}', fontsize=8)\n",
    "    axes[row, col].axis('off')\n",
    "    plt.colorbar(im, ax=axes[row, col], fraction=0.046, pad=0.04)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. 空间特征提取"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 创建空间特征提取器\n",
    "spatial_extractor = SpatialFeatureExtractor(\n",
    "    methods=['morphological', 'geometric', 'contextual'],\n",
    "    kernel_sizes=[3, 5, 7, 9],\n",
    "    connectivity=8\n",
    ")\n",
    "\n",
    "print(\"开始提取空间特征...\")\n",
    "\n",
    "# 计算主成分用于空间特征提取\n",
    "h, w, n_bands = hyperspectral_data.shape\n",
    "reshaped_data = hyperspectral_data.reshape(-1, n_bands)\n",
    "\n",
    "# PCA降维\n",
    "pca = PCA(n_components=10)\n",
    "pca_data = pca.fit_transform(reshaped_data)\n",
    "pca_image = pca_data.reshape(h, w, 10)\n",
    "\n",
    "print(f\"PCA解释方差比: {pca.explained_variance_ratio_[:5]}\")\n",
    "\n",
    "# 提取空间特征\n",
    "spatial_features = spatial_extractor.extract_features(pca_image[:, :, :3])  # 使用前3个主成分\n",
    "\n",
    "print(f\"空间特征提取完成\")\n",
    "print(f\"空间特征形状: {spatial_features.shape}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 可视化空间特征\n",
    "fig, axes = plt.subplots(3, 4, figsize=(16, 12))\n",
    "axes = axes.flatten()\n",
    "\n",
    "spatial_feature_names = spatial_extractor.get_feature_names()\n",
    "features_to_show = min(12, spatial_features.shape[2])\n",
    "\n",
    "for i in range(features_to_show):\n",
    "    feature_data = spatial_features[:, :, i]\n",
    "    \n",
    "    # 处理异常值\n",
    "    vmin, vmax = np.percentile(feature_data[np.isfinite(feature_data)], [2, 98])\n",
    "    \n",
    "    im = axes[i].imshow(feature_data, cmap='plasma', vmin=vmin, vmax=vmax)\n",
    "    if i < len(spatial_feature_names):\n",
    "        axes[i].set_title(f'{spatial_feature_names[i]}', fontsize=10)\n",
    "    else:\n",
    "        axes[i].set_title(f'Spatial Feature {i+1}', fontsize=10)\n",
    "    axes[i].axis('off')\n",
    "    plt.colorbar(im, ax=axes[i], fraction=0.046, pad=0.04)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. 特征融合与组织"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 特征融合\n",
    "print(\"开始特征融合...\")\n",
    "\n",
    "# 确保所有特征具有相同的空间维度\n",
    "h, w = hyperspectral_data.shape[:2]\n",
    "\n",
    "# 重塑特征为二维数组 (像素数, 特征数)\n",
    "features_list = []\n",
    "feature_names_list = []\n",
    "\n",
    "# 1. 原始光谱特征\n",
    "original_features = hyperspectral_data.reshape(-1, hyperspectral_data.shape[2])\n",
    "features_list.append(original_features)\n",
    "feature_names_list.extend([f'Band_{i+1}' for i in range(hyperspectral_data.shape[2])])\n",
    "\n",
    "# 2. 光谱衍生特征\n",
    "if spectral_features.ndim == 3:\n",
    "    spectral_features_2d = spectral_features.reshape(-1, spectral_features.shape[2])\n",
    "    features_list.append(spectral_features_2d)\n",
    "    feature_names_list.extend(spectral_extractor.get_feature_names())\n",
    "\n",
    "# 3. 植被指数\n",
    "vegetation_features_2d = vegetation_features.reshape(-1, vegetation_features.shape[2])\n",
    "features_list.append(vegetation_features_2d)\n",
    "feature_names_list.extend(vegetation_indices.get_index_names())\n",
    "\n",
    "# 4. 纹理特征\n",
    "texture_features_2d = texture_features.reshape(-1, texture_features.shape[2])\n",
    "features_list.append(texture_features_2d)\n",
    "texture_names = [f'Texture_{i+1}' for i in range(texture_features.shape[2])]\n",
    "feature_names_list.extend(texture_names)\n",
    "\n",
    "# 5. 空间特征\n",
    "spatial_features_2d = spatial_features.reshape(-1, spatial_features.shape[2])\n",
    "features_list.append(spatial_features_2d)\n",
    "spatial_names = [f'Spatial_{i+1}' for i in range(spatial_features.shape[2])]\n",
    "feature_names_list.extend(spatial_names)\n",
    "\n",
    "# 合并所有特征\n",
    "all_features = np.concatenate(features_list, axis=1)\n",
    "\n",
    "print(f\"特征融合完成\")\n",
    "print(f\"总特征数量: {all_features.shape[1]}\")\n",
    "print(f\"特征分布:\")\n",
    "print(f\"  - 原始光谱: {original_features.shape[1]}\")\n",
    "print(f\"  - 光谱衍生: {spectral_features_2d.shape[1] if spectral_features.ndim == 3 else 0}\")\n",
    "print(f\"  - 植被指数: {vegetation_features_2d.shape[1]}\")\n",
    "print(f\"  - 纹理特征: {texture_features_2d.shape[1]}\")\n",
    "print(f\"  - 空间特征: {spatial_features_2d.shape[1]}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 特征预处理\n",
    "print(\"开始特征预处理...\")\n",
    "\n",
    "# 处理无效值\n",
    "all_features = np.nan_to_num(all_features, nan=0, posinf=0, neginf=0)\n",
    "\n",
    "# 标准化\n",
    "scaler = StandardScaler()\n",
    "all_features_scaled = scaler.fit_transform(all_features)\n",
    "\n",
    "print(f\"特征预处理完成\")\n",
    "print(f\"标准化后特征统计:\")\n",
    "print(f\"  - 均值: {np.mean(all_features_scaled):.6f}\")\n",
    "print(f\"  - 标准差: {np.std(all_features_scaled):.6f}\")\n",
    "print(f\"  - 最小值: {np.min(all_features_scaled):.3f}\")\n",
    "print(f\"  - 最大值: {np.max(all_features_scaled):.3f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. 特征选择"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 如果有训练样本，进行监督特征选择\n",
    "if training_samples is not None:\n",
    "    print(\"开始监督特征选择...\")\n",
    "    \n",
    "    # 提取训练样本对应的特征和标签\n",
    "    # 这里需要根据实际的样本格式进行调整\n",
    "    # 假设我们随机选择一些样本作为示例\n",
    "    n_samples = min(5000, all_features_scaled.shape[0])\n",
    "    sample_indices = np.random.choice(all_features_scaled.shape[0], n_samples, replace=False)\n",
    "    X_sample = all_features_scaled[sample_indices]\n",
    "    \n",
    "    # 模拟标签（实际应用中需要从训练样本中提取）\n",
    "    y_sample = np.random.randint(0, 5, n_samples)  # 假设5个类别\n",
    "    \n",
    "    # 1. 基于方差的特征选择\n",
    "    from sklearn.feature_selection import VarianceThreshold\n",
    "    variance_selector = VarianceThreshold(threshold=0.01)\n",
    "    X_variance = variance_selector.fit_transform(X_sample)\n",
    "    \n",
    "    # 2. 基于F统计量的特征选择\n",
    "    f_selector = SelectKBest(f_classif, k=min(500, X_variance.shape[1]))\n",
    "    X_f_selected = f_selector.fit_transform(X_variance, y_sample)\n",
    "    \n",
    "    # 3. 基于互信息的特征选择\n",
    "    mi_selector = SelectKBest(mutual_info_classif, k=min(300, X_f_selected.shape[1]))\n",
    "    X_mi_selected = mi_selector.fit_transform(X_f_selected, y_sample)\n",
    "    \n",
    "    # 4. 基于随机森林的特征重要性\n",
    "    rf = RandomForestClassifier(n_estimators=100, random_state=42)\n",
    "    rf.fit(X_mi_selected, y_sample)\n",
    "    \n",
    "    feature_importances = rf.feature_importances_\n",
    "    \n",
    "    print(f\"特征选择结果:\")\n",
    "    print(f\"  - 原始特征数: {all_features_scaled.shape[1]}\")\n",
    "    print(f\"  - 方差过滤后: {X_variance.shape[1]}\")\n",
    "    print(f\"  - F统计量选择后: {X_f_selected.shape[1]}\")\n",
    "    print(f\"  - 互信息选择后: {X_mi_selected.shape[1]}\")\n",
    "    \n",
    "else:\n",
    "    print(\"未提供训练样本，进行无监督特征选择...\")\n",
    "    \n",
    "    # 无监督特征选择\n",
    "    # 1. 基于方差的特征选择\n",
    "    from sklearn.feature_selection import VarianceThreshold\n",
    "    variance_selector = VarianceThreshold(threshold=0.01)\n",
    "    selected_features = variance_selector.fit_transform(all_features_scaled)\n",
    "    \n",
    "    print(f\"无监督特征选择结果:\")\n",
    "    print(f\"  - 原始特征数: {all_features_scaled.shape[1]}\")\n",
    "    print(f\"  - 方差过滤后: {selected_features.shape[1]}\")\n",
    "    \n",
    "    feature_importances = None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 可视化特征重要性（如果有的话）\n",
    "if feature_importances is not None:\n",
    "    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))\n",
    "    \n",
    "    # 特征重要性分布\n",
    "    ax1.hist(feature_importances, bins=50, alpha=0.7, color='skyblue')\n",
    "    ax1.set_title('特征重要性分布')\n",
    "    ax1.set_xlabel('重要性得分')\n",
    "    ax1.set_ylabel('频次')\n",
    "    ax1.grid(True, alpha=0.3)\n",
    "    \n",
    "    # Top 20 重要特征\n",
    "    top_indices = np.argsort(feature_importances)[-20:]\n",
    "    top_importances = feature_importances[top_indices]\n",
    "    \n",
    "    ax2.barh(range(20), top_importances, color='lightcoral')\n",
    "    ax2.set_title('Top 20 重要特征')\n",
    "    ax2.set_xlabel('重要性得分')\n",
    "    ax2.set_ylabel('特征排名')\n",
    "    ax2.grid(True, alpha=0.3)\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    # 打印最重要的特征\n",
    "    print(\"\\nTop 10 最重要特征:\")\n",
    "    for i, idx in enumerate(top_indices[-10:]):\n",
    "        print(f\"{i+1:2d}. 特征 {idx:3d}: {feature_importances[idx]:.4f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 8. 降维分析"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 主成分分析 (PCA)\n",
    "print(\"开始降维分析...\")\n",
    "\n",
    "# PCA分析\n",
    "pca_full = PCA()\n",
    "pca_features = pca_full.fit_transform(all_features_scaled)\n",
    "\n",
    "# 计算累积解释方差\n",
    "cumsum_var_ratio = np.cumsum(pca_full.explained_variance_ratio_)\n",
    "\n",
    "# 找到解释95%方差所需的主成分数\n",
    "n_components_95 = np.argmax(cumsum_var_ratio >= 0.95) + 1\n",
    "n_components_99 = np.argmax(cumsum_var_ratio >= 0.99) + 1\n",
    "\n",
    "print(f\"PCA分析结果:\")\n",
    "print(f\"  - 解释95%方差需要: {n_components_95} 个主成分\")\n",
    "print(f\"  - 解释99%方差需要: {n_components_99} 个主成分\")\n",
    "print(f\"  - 前10个主成分解释方差比: {pca_full.explained_variance_ratio_[:10]}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 可视化降维结果\n",
    "fig, axes = plt.subplots(2, 3, figsize=(18, 12))\n",
    "\n",
    "# 1. 解释方差比\n",
    "axes[0, 0].plot(range(1, min(51, len(pca_full.explained_variance_ratio_) + 1)), \n",
    "                pca_full.explained_variance_ratio_[:50], 'bo-', markersize=3)\n",
    "axes[0, 0].set_title('主成分解释方差比')\n",
    "axes[0, 0].set_xlabel('主成分')\n",
    "axes[0, 0].set_ylabel('解释方差比')\n",
    "axes[0, 0].grid(True, alpha=0.3)\n",
    "\n",
    "# 2. 累积解释方差比\n",
    "axes[0, 1].plot(range(1, min(101, len(cumsum_var_ratio) + 1)), \n",
    "                cumsum_var_ratio[:100], 'ro-', markersize=2)\n",
    "axes[0, 1].axhline(y=0.95, color='g', linestyle='--', label='95%')\n",
    "axes[0, 1].axhline(y=0.99, color='b', linestyle='--', label='99%')\n",
    "axes[0, 1].set_title('累积解释方差比')\n",
    "axes[0, 1].set_xlabel('主成分数量')\n",
    "axes[0, 1].set_ylabel('累积解释方差比')\n",
    "axes[0, 1].legend()\n",
    "axes[0, 1].grid(True, alpha=0.3)\n",
    "\n",
    "# 3-6. 前4个主成分的空间分布\n",
    "for i in range(4):\n",
    "    pc_image = pca_features[:, i].reshape(h, w)\n",
    "    im = axes[i//2 + (0 if i < 2 else 1), (i%2) + (2 if i < 2 else 0)].imshow(\n",
    "        pc_image, cmap='RdBu_r'\n",
    "    )\n",
    "    axes[i//2 + (0 if i < 2 else 1), (i%2) + (2 if i < 2 else 0)].set_title(\n",
    "        f'PC{i+1} ({pca_full.explained_variance_ratio_[i]:.1%})'\n",
    "    )\n",
    "    axes[i//2 + (0 if i < 2 else 1), (i%2) + (2 if i < 2 else 0)].axis('off')\n",
    "    plt.colorbar(im, ax=axes[i//2 + (0 if i < 2 else 1), (i%2) + (2 if i < 2 else 0)], \n",
    "                 fraction=0.046, pad=0.04)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 其他降维方法比较\n",
    "print(\"比较不同降维方法...\")\n",
    "\n",
    "# 选择子集进行快速计算\n",
    "subset_size = min(5000, all_features_scaled.shape[0])\n",
    "subset_indices = np.random.choice(all_features_scaled.shape[0], subset_size, replace=False)\n",
    "X_subset = all_features_scaled[subset_indices]\n",
    "\n",
    "# 1. ICA\n",
    "ica = FastICA(n_components=10, random_state=42)\n",
    "ica_features = ica.fit_transform(X_subset)\n",
    "\n",
    "# 2. NMF (非负矩阵分解)\n",
    "# 确保数据为非负\n",
    "X_subset_positive = X_subset - X_subset.min() + 1e-10\n",
    "nmf = NMF(n_components=10, random_state=42)\n",
    "nmf_features = nmf.fit_transform(X_subset_positive)\n",
    "\n",
    "# 3. t-SNE (仅用于可视化)\n",
    "tsne = TSNE(n_components=2, random_state=42, perplexity=30)\n",
    "tsne_features = tsne.fit_transform(X_subset[:1000])  # 仅使用1000个样本\n",
    "\n",
    "print(f\"降维方法比较完成\")\n",
    "print(f\"  - PCA: {pca_features[:subset_size].shape}\")\n",
    "print(f\"  - ICA: {ica_features.shape}\")\n",
    "print(f\"  - NMF: {nmf_features.shape}\")\n",
    "print(f\"  - t-SNE: {tsne_features.shape}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 可视化不同降维方法的结果\n",
    "fig, axes = plt.subplots(2, 2, figsize=(12, 10))\n",
    "\n",
    "# PCA前两个主成分\n",
    "axes[0, 0].scatter(pca_features[subset_indices, 0], pca_features[subset_indices, 1], \n",
    "                   alpha=0.6, s=1)\n",
    "axes[0, 0].set_title('PCA (PC1 vs PC2)')\n",
    "axes[0, 0].set_xlabel('PC1')\n",
    "axes[0, 0].set_ylabel('PC2')\n",
    "\n",
    "# ICA前两个成分\n",
    "axes[0, 1].scatter(ica_features[:, 0], ica_features[:, 1], alpha=0.6, s=1)\n",
    "axes[0, 1].set_title('ICA (IC1 vs IC2)')\n",
    "axes[0, 1].set_xlabel('IC1')\n",
    "axes[0, 1].set_ylabel('IC2')\n",
    "\n",
    "# NMF前两个成分\n",
    "axes[1, 0].scatter(nmf_features[:, 0], nmf_features[:, 1], alpha=0.6, s=1)\n",
    "axes[1, 0].set_title('NMF (Component 1 vs 2)')\n",
    "axes[1, 0].set_xlabel('Component 1')\n",
    "axes[1, 0].set_ylabel('Component 2')\n",
    "\n",
    "# t-SNE\n",
    "axes[1, 1].scatter(tsne_features[:, 0], tsne_features[:, 1], alpha=0.6, s=1)\n",
    "axes[1, 1].set_title('t-SNE')\n",
    "axes[1, 1].set_xlabel('t-SNE 1')\n",
    "axes[1, 1].set_ylabel('t-SNE 2')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 9. 保存特征工程结果"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 保存特征工程结果\n",
    "print(\"保存特征工程结果...\")\n",
    "\n",
    "# 1. 保存完整特征集\n",
    "np.save(output_dir / 'all_features.npy', all_features_scaled)\n",
    "np.save(output_dir / 'feature_names.npy', np.array(feature_names_list))\n",
    "\n",
    "# 2. 保存PCA结果\n",
    "np.save(output_dir / 'pca_features.npy', pca_features)\n",
    "np.save(output_dir / 'pca_explained_variance_ratio.npy', pca_full.explained_variance_ratio_)\n",
    "\n",
    "# 3. 保存降维到95%方差的主成分\n",
    "pca_95_features = pca_features[:, :n_components_95]\n",
    "np.save(output_dir / 'pca_95_features.npy', pca_95_features)\n",
    "\n",
    "# 4. 保存各类特征\n",
    "np.save(output_dir / 'vegetation_indices.npy', vegetation_features)\n",
    "np.save(output_dir / 'texture_features.npy', texture_features)\n",
    "np.save(output_dir / 'spatial_features.npy', spatial_features)\n",
    "\n",
    "# 5. 保存预处理器\n",
    "import joblib\n",
    "joblib.dump(scaler, output_dir / 'feature_scaler.pkl')\n",
    "joblib.dump(pca_full, output_dir / 'pca_model.pkl')\n",
    "\n",
    "if feature_importances is not None:\n",
    "    np.save(output_dir / 'feature_importances.npy', feature_importances)\n",
    "\n",
    "print(f\"特征工程结果已保存到: {output_dir}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 生成特征工程报告\n",
    "feature_report = {\n",
    "    '数据概况': {\n",
    "        '原始数据形状': str(hyperspectral_data.shape),\n",
    "        '总像素数': int(h * w),\n",
    "        '原始波段数': int(hyperspectral_data.shape[2]),\n",
    "        '波长范围': f'{wavelengths[0]:.1f} - {wavelengths[-1]:.1f} nm'\n",
    "    },\n",
    "    '特征统计': {\n",
    "        '总特征数': int(all_features_scaled.shape[1]),\n",
    "        '原始光谱特征': int(original_features.shape[1]),\n",
    "        '植被指数数量': int(vegetation_features_2d.shape[1]),\n",
    "        '纹理特征数量': int(texture_features_2d.shape[1]),\n",
    "        '空间特征数量': int(spatial_features_2d.shape[1])\n",
    "    },\n",
    "    '降维分析': {\n",
    "        '95%方差主成分数': int(n_components_95),\n",
    "        '99%方差主成分数': int(n_components_99),\n",
    "        '前5个PC解释方差': [float(x) for x in pca_full.explained_variance_ratio_[:5]],\n",
    "        '维度压缩比': f'{n_components_95}/{all_features_scaled.shape[1]} ({n_components_95/all_features_scaled.shape[1]:.1%})'\n",
    "    },\n",
    "    '处理设置': {\n",
    "        '标准化方法': 'StandardScaler',\n",
    "        '纹理分析波段': texture_bands,\n",
    "        '空间特征方法': spatial_extractor.methods if hasattr(spatial_extractor, 'methods') else 'Unknown',\n",
    "        '植被指数类型': len(vegetation_indices.get_index_names())\n",
    "    }\n",
    "}\n",
    "\n",
    "# 保存报告\n",
    "import json\n",
    "with open(output_dir / 'feature_engineering_report.json', 'w', encoding='utf-8') as f:\n",
    "    json.dump(feature_report, f, indent=2, ensure_ascii=False)\n",
    "\n",
    "# 打印报告\n",
    "print(\"\\n\" + \"=\"*50)\n",
    "print(\"湿地高光谱特征工程报告\")\n",
    "print(\"=\"*50)\n",
    "\n",
    "for section, items in feature_report.items():\n",
    "    print(f\"\\n{section}:\")\n",
    "    for key, value in items.items():\n",
    "        print(f\"  {key}: {value}\")\n",
    "\n",
    "print(f\"\\n特征工程报告已保存到: {output_dir / 'feature_engineering_report.json'}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 总结\n",
    "\n",
    "本notebook完成了湿地高光谱数据的全面特征工程:\n",
    "\n",
    "### 🔍 主要成果:\n",
    "1. **多维特征提取**: 成功提取了光谱、植被、纹理和空间四大类特征\n",
    "2. **特征融合**: 构建了综合特征集，为分类分析提供丰富信息\n",
    "3. **降维优化**: 通过PCA分析实现了有效的维度压缩\n",
    "4. **质量评估**: 全面评估了特征的统计特性和重要性\n",
    "\n",
    "### 📊 关键指标:\n",
    "- 总特征数量: {}\n",
    "- 95%方差保留的主成分数: {}\n",
    "- 维度压缩比: {:.1%}\n",
    "- 特征质量: 高质量，已标准化处理\n",
    "\n",
    "### 🎯 下一步工作:\n",
    "1. 使用提取的特征进行模型训练\n",
    "2. 比较不同特征组合的分类效果\n",
    "3. 优化特征选择策略\n",
    "4. 进行深度学习模型的端到端训练\n",
    "\n",
    "特征工程是成功分类的基础，本阶段为后续的模型训练和分析奠定了坚实基础。\n",
    "\".format(\n",
    "    all_features_scaled.shape[1],\n",
    "    n_components_95, \n",
    "    n_components_95/all_features_scaled.shape[1]\n",
    ")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",\n",
   "language": "python",\n",
   "name": "python3"\n",
  },\n",
  "language_info": {\n",
   "codemirror_mode": {\n",
    "name": "ipython",\n",
    "version": 3\n",
   },\n",
   "file_extension": ".py",\n",
   "mimetype": "text/x-python",\n",
   "name": "python",\n",
   "nbconvert_exporter": "python",\n",
   "pygments_lexer": "ipython3",\n",
   "version": "3.9.0"\n",
  }\n },\n "nbformat": 4,\n "nbformat_minor": 4\n}
  