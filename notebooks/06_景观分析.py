{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 湿地景观格局分析\n",
    "\n",
    "## 概述\n",
    "本notebook基于高光谱分类结果进行湿地景观格局分析，包括：\n",
    "- 景观指数计算\n",
    "- 斑块特征分析\n",
    "- 连通性分析\n",
    "- 边缘效应分析\n",
    "- 多样性与均匀性分析\n",
    "- 景观破碎化评估\n",
    "- 空间格局变化分析\n",
    "- 生态功能评估\n",
    "\n",
    "景观格局分析对于理解湿地生态系统的空间结构、功能特征和生态过程具有重要意义。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 导入必要的库\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from pathlib import Path\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "# 图像处理和空间分析\n",
    "import cv2\n",
    "from skimage import measure, morphology, filters, segmentation\n",
    "from skimage.morphology import disk, square, remove_small_objects\n",
    "from skimage.measure import label, regionprops\n",
    "from scipy import ndimage\n",
    "from scipy.spatial.distance import pdist, squareform\n",
    "from scipy.stats import entropy\n",
    "\n",
    "# 地理空间分析\n",
    "import rasterio\n",
    "from rasterio.features import shapes\n",
    "import geopandas as gpd\n",
    "from shapely.geometry import shape, Point, Polygon\n",
    "from shapely.ops import unary_union\n",
    "\n",
    "# 网络分析\n",
    "import networkx as nx\n",
    "from sklearn.neighbors import NearestNeighbors\n",
    "\n",
    "# 可视化\n",
    "import plotly.graph_objects as go\n",
    "import plotly.express as px\n",
    "from plotly.subplots import make_subplots\n",
    "\n",
    "# 其他工具\n",
    "import json\n",
    "from collections import Counter\n",
    "import itertools\n",
    "\n",
    "# 自定义模块\n",
    "import sys\n",
    "sys.path.append('../src')\n",
    "from wetland_classification.landscape import (\n",
    "    LandscapeAnalyzer, PatchAnalyzer, \n",
    "    ConnectivityAnalyzer, FragmentationAnalyzer\n",
    ")\n",
    "from wetland_classification.utils import visualization, logger\n",
    "\n",
    "# 设置绘图样式\n",
    "plt.style.use('seaborn-v0_8')\n",
    "sns.set_palette(\"husl\")\n",
    "plt.rcParams['figure.dpi'] = 100\n",
    "plt.rcParams['savefig.dpi'] = 300\n",
    "\n",
    "# 配置日志\n",
    "logger = logger.setup_logger('landscape_analysis', level='INFO')\n",
    "\n",
    "print(\"景观分析环境初始化完成！\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. 数据加载与预处理"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 设置路径\n",
    "output_dir = Path('../output')\n",
    "model_dir = Path('../models')\n",
    "landscape_dir = Path('../output/landscape')\n",
    "landscape_dir.mkdir(exist_ok=True)\n",
    "\n",
    "# 加载分类结果\n",
    "print(\"加载分类结果数据...\")\n",
    "\n",
    "# 模拟加载分类结果（实际应用中从保存的文件加载）\n",
    "# 这里重新生成分类数据作为演示\n",
    "feature_dir = Path('../data/features')\n",
    "all_features = np.load(feature_dir / 'all_features.npy')\n",
    "pca_95_features = np.load(feature_dir / 'pca_95_features.npy')\n",
    "\n",
    "# 重新生成分类结果\n",
    "from sklearn.cluster import KMeans\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "np.random.seed(42)\n",
    "kmeans = KMeans(n_clusters=5, random_state=42, n_init=10)\n",
    "y_labels = kmeans.fit_predict(pca_95_features)\n",
    "\n",
    "# 训练一个简单的分类器\n",
    "X_train, X_test, y_train, y_test = train_test_split(\n",
    "    all_features, y_labels, test_size=0.3, random_state=42, stratify=y_labels\n",
    ")\n",
    "rf_model = RandomForestClassifier(n_estimators=100, random_state=42)\n",
    "rf_model.fit(X_train, y_train)\n",
    "all_predictions = rf_model.predict(all_features)\n",
    "\n",
    "# 定义类别名称和颜色\n",
    "class_names = {\n",
    "    0: '开放水面',\n",
    "    1: '挺水植物',\n",
    "    2: '浮叶植物', \n",
    "    3: '湿生草本',\n",
    "    4: '土壤/裸地'\n",
    "}\n",
    "\n",
    "class_colors = {\n",
    "    0: '#1f77b4',  # 蓝色 - 开放水面\n",
    "    1: '#2ca02c',  # 绿色 - 挺水植物\n",
    "    2: '#ff7f0e',  # 橙色 - 浮叶植物\n",
    "    3: '#d62728',  # 红色 - 湿生草本\n",
    "    4: '#9467bd'   # 紫色 - 土壤/裸地\n",
    "}\n",
    "\n",
    "# 重塑为二维分类图\n",
    "total_pixels = len(all_predictions)\n",
    "img_height = int(np.sqrt(total_pixels * 0.75))\n",
    "img_width = int(total_pixels / img_height)\n",
    "\n",
    "if img_height * img_width < total_pixels:\n",
    "    img_width += 1\n",
    "\n",
    "classification_map = all_predictions[:img_height * img_width].reshape(img_height, img_width)\n",
    "\n",
    "print(f\"分类图尺寸: {img_height} x {img_width}\")\n",
    "print(f\"类别数量: {len(class_names)}\")\n",
    "print(\"类别统计:\")\n",
    "for class_id, count in zip(*np.unique(classification_map, return_counts=True)):\n",
    "    percentage = count / classification_map.size * 100\n",
    "    print(f\"  {class_names[class_id]}: {count} 像素 ({percentage:.2f}%)\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 数据预处理和质量检查\n",
    "print(\"进行数据预处理和质量检查...\")\n",
    "\n",
    "# 去除小斑块噪声\n",
    "min_patch_size = 5  # 最小斑块大小（像素）\n",
    "cleaned_map = classification_map.copy()\n",
    "\n",
    "for class_id in range(len(class_names)):\n",
    "    # 创建二值掩码\n",
    "    binary_mask = (classification_map == class_id).astype(np.uint8)\n",
    "    \n",
    "    # 去除小斑块\n",
    "    cleaned_mask = remove_small_objects(\n",
    "        binary_mask.astype(bool), \n",
    "        min_size=min_patch_size\n",
    "    )\n",
    "    \n",
    "    # 更新分类图\n",
    "    removed_pixels = binary_mask.astype(bool) & ~cleaned_mask\n",
    "    if np.any(removed_pixels):\n",
    "        # 将去除的像素分配给最邻近的其他类别\n",
    "        structure = ndimage.generate_binary_structure(2, 2)\n",
    "        for removed_pixel in np.column_stack(np.where(removed_pixels)):\n",
    "            y, x = removed_pixel\n",
    "            # 查找邻近像素的类别\n",
    "            neighbors = []\n",
    "            for dy in [-1, 0, 1]:\n",
    "                for dx in [-1, 0, 1]:\n",
    "                    ny, nx = y + dy, x + dx\n",
    "                    if (0 <= ny < img_height and 0 <= nx < img_width and \n",
    "                        cleaned_map[ny, nx] != class_id):\n",
    "                        neighbors.append(cleaned_map[ny, nx])\n",
    "            \n",
    "            if neighbors:\n",
    "                # 分配给最常见的邻近类别\n",
    "                most_common = Counter(neighbors).most_common(1)[0][0]\n",
    "                cleaned_map[y, x] = most_common\n",
    "\n",
    "# 形态学处理\n",
    "smoothed_map = cleaned_map.copy()\n",
    "kernel = disk(1)  # 小的圆形核\n",
    "\n",
    "for class_id in range(len(class_names)):\n",
    "    binary_mask = (cleaned_map == class_id).astype(np.uint8)\n",
    "    # 开运算：先腐蚀后膨胀，去除小噪声\n",
    "    opened = morphology.opening(binary_mask, kernel)\n",
    "    # 闭运算：先膨胀后腐蚀，填充小孔洞\n",
    "    closed = morphology.closing(opened, kernel)\n",
    "    \n",
    "    # 更新分类图\n",
    "    smoothed_map[closed.astype(bool)] = class_id\n",
    "\n",
    "print(\"数据预处理完成\")\n",
    "print(f\"原始像素数: {classification_map.size}\")\n",
    "print(f\"处理后像素数: {smoothed_map.size}\")\n",
    "\n",
    "# 使用处理后的分类图进行后续分析\n",
    "final_classification_map = smoothed_map"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. 基础景观指数计算"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 计算基础景观指数\n",
    "print(\"计算基础景观指数...\")\n",
    "\n",
    "def calculate_basic_metrics(class_map):\n",
    "    \"\"\"\n",
    "    计算基础景观指数\n",
    "    \"\"\"\n",
    "    metrics = {}\n",
    "    \n",
    "    # 景观总面积\n",
    "    total_area = class_map.size\n",
    "    \n",
    "    # 各类别面积和比例\n",
    "    class_areas = {}\n",
    "    class_proportions = {}\n",
    "    \n",
    "    for class_id in range(len(class_names)):\n",
    "        area = np.sum(class_map == class_id)\n",
    "        class_areas[class_id] = area\n",
    "        class_proportions[class_id] = area / total_area\n",
    "    \n",
    "    metrics['total_area'] = total_area\n",
    "    metrics['class_areas'] = class_areas\n",
    "    metrics['class_proportions'] = class_proportions\n",
    "    \n",
    "    # Shannon多样性指数\n",
    "    proportions = list(class_proportions.values())\n",
    "    proportions = [p for p in proportions if p > 0]  # 移除零值\n",
    "    shannon_diversity = -sum(p * np.log(p) for p in proportions)\n",
    "    metrics['shannon_diversity'] = shannon_diversity\n",
    "    \n",
    "    # Simpson多样性指数\n",
    "    simpson_diversity = 1 - sum(p**2 for p in proportions)\n",
    "    metrics['simpson_diversity'] = simpson_diversity\n",
    "    \n",
    "    # 均匀度指数\n",
    "    max_diversity = np.log(len([p for p in proportions if p > 0]))\n",
    "    evenness = shannon_diversity / max_diversity if max_diversity > 0 else 0\n",
    "    metrics['evenness'] = evenness\n",
    "    \n",
    "    # 优势度指数\n",
    "    dominance = max(proportions) if proportions else 0\n",
    "    metrics['dominance'] = dominance\n",
    "    \n",
    "    return metrics\n",
    "\n",
    "basic_metrics = calculate_basic_metrics(final_classification_map)\n",
    "\n",
    "print(\"基础景观指数:\")\n",
    "print(f\"总面积: {basic_metrics['total_area']} 像素\")\n",
    "print(f\"Shannon多样性指数: {basic_metrics['shannon_diversity']:.4f}\")\n",
    "print(f\"Simpson多样性指数: {basic_metrics['simpson_diversity']:.4f}\")\n",
    "print(f\"均匀度指数: {basic_metrics['evenness']:.4f}\")\n",
    "print(f\"优势度指数: {basic_metrics['dominance']:.4f}\")\n",
    "\n",
    "print(\"\\n各类别面积比例:\")\n",
    "for class_id, proportion in basic_metrics['class_proportions'].items():\n",
    "    print(f\"{class_names[class_id]}: {proportion:.4f} ({proportion*100:.2f}%)\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 可视化基础指数\n",
    "fig, axes = plt.subplots(2, 2, figsize=(15, 12))\n",
    "\n",
    "# 原始分类图\n",
    "colors = [class_colors[i] for i in range(len(class_names))]\n",
    "cmap = plt.matplotlib.colors.ListedColormap(colors)\n",
    "\n",
    "im1 = axes[0, 0].imshow(final_classification_map, cmap=cmap, vmin=0, vmax=len(class_names)-1)\n",
    "axes[0, 0].set_title('湿地分类图', fontsize=14)\n",
    "axes[0, 0].axis('off')\n",
    "\n",
    "# 添加图例\n",
    "legend_elements = [plt.matplotlib.patches.Patch(color=colors[i], label=class_names[i]) \n",
    "                  for i in range(len(class_names))]\n",
    "axes[0, 0].legend(handles=legend_elements, loc='center left', bbox_to_anchor=(1, 0.5))\n",
    "\n",
    "# 类别面积饼图\n",
    "areas = [basic_metrics['class_areas'][i] for i in range(len(class_names))]\n",
    "labels = [class_names[i] for i in range(len(class_names))]\n",
    "axes[0, 1].pie(areas, labels=labels, autopct='%1.1f%%', colors=colors, startangle=90)\n",
    "axes[0, 1].set_title('各类别面积比例', fontsize=14)\n",
    "\n",
    "# 多样性指数对比\n",
    "diversity_metrics = ['Shannon多样性', 'Simpson多样性', '均匀度', '优势度']\n",
    "diversity_values = [\n",
    "    basic_metrics['shannon_diversity'],\n",
    "    basic_metrics['simpson_diversity'], \n",
    "    basic_metrics['evenness'],\n",
    "    basic_metrics['dominance']\n",
    "]\n",
    "\n",
    "bars = axes[1, 0].bar(diversity_metrics, diversity_values, \n",
    "                     color=['skyblue', 'lightgreen', 'lightcoral', 'gold'], alpha=0.8)\n",
    "axes[1, 0].set_ylabel('指数值')\n",
    "axes[1, 0].set_title('景观多样性指数', fontsize=14)\n",
    "axes[1, 0].tick_params(axis='x', rotation=45)\n",
    "axes[1, 0].grid(True, alpha=0.3)\n",
    "\n",
    "# 添加数值标签\n",
    "for bar, value in zip(bars, diversity_values):\n",
    "    axes[1, 0].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.01, \n",
    "                   f'{value:.3f}', ha='center', va='bottom')\n",
    "\n",
    "# 类别面积条形图\n",
    "x_pos = np.arange(len(class_names))\n",
    "bars = axes[1, 1].bar(x_pos, areas, color=colors, alpha=0.8)\n",
    "axes[1, 1].set_xlabel('类别')\n",
    "axes[1, 1].set_ylabel('面积 (像素)')\n",
    "axes[1, 1].set_title('各类别面积统计', fontsize=14)\n",
    "axes[1, 1].set_xticks(x_pos)\n",
    "axes[1, 1].set_xticklabels(labels, rotation=45)\n",
    "axes[1, 1].grid(True, alpha=0.3)\n",
    "\n",
    "# 添加数值标签\n",
    "for bar, area in zip(bars, areas):\n",
    "    axes[1, 1].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(areas)*0.01, \n",
    "                   f'{area}', ha='center', va='bottom', fontsize=9)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. 斑块特征分析"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 斑块识别和特征计算\n",
    "print(\"进行斑块特征分析...\")\n",
    "\n",
    "def analyze_patches(class_map):\n",
    "    \"\"\"\n",
    "    分析各类别的斑块特征\n",
    "    \"\"\"\n",
    "    patch_metrics = {}\n",
    "    \n",
    "    for class_id in range(len(class_names)):\n",
    "        # 创建二值掩码\n",
    "        binary_mask = (class_map == class_id).astype(np.uint8)\n",
    "        \n",
    "        # 连通组件标记\n",
    "        labeled_patches = label(binary_mask, connectivity=2)\n",
    "        \n",
    "        # 获取斑块属性\n",
    "        props = regionprops(labeled_patches)\n",
    "        \n",
    "        if len(props) == 0:\n",
    "            patch_metrics[class_id] = {\n",
    "                'num_patches': 0,\n",
    "                'total_area': 0,\n",
    "                'mean_area': 0,\n",
    "                'std_area': 0,\n",
    "                'min_area': 0,\n",
    "                'max_area': 0,\n",
    "                'patch_areas': [],\n",
    "                'mean_perimeter': 0,\n",
    "                'mean_shape_index': 0,\n",
    "                'mean_fractal_dimension': 0\n",
    "            }\n",
    "            continue\n",
    "        \n",
    "        # 基础斑块统计\n",
    "        patch_areas = [prop.area for prop in props]\n",
    "        num_patches = len(props)\n",
    "        total_area = sum(patch_areas)\n",
    "        mean_area = np.mean(patch_areas)\n",
    "        std_area = np.std(patch_areas)\n",
    "        min_area = min(patch_areas)\n",
    "        max_area = max(patch_areas)\n",
    "        \n",
    "        # 形状指数计算\n",
    "        perimeters = []\n",
    "        shape_indices = []\n",
    "        fractal_dimensions = []\n",
    "        \n",
    "        for prop in props:\n",
    "            # 周长\n",
    "            perimeter = prop.perimeter\n",
    "            perimeters.append(perimeter)\n",
    "            \n",
    "            # 形状指数 (Shape Index) = 周长 / (2 * sqrt(π * 面积))\n",
    "            shape_index = perimeter / (2 * np.sqrt(np.pi * prop.area)) if prop.area > 0 else 0\n",
    "            shape_indices.append(shape_index)\n",
    "            \n",
    "            # 分形维数近似 = 2 * ln(周长) / ln(面积)\n",
    "            if prop.area > 1 and perimeter > 0:\n",
    "                fractal_dim = 2 * np.log(perimeter) / np.log(prop.area)\n",
    "            else:\n",
    "                fractal_dim = 0\n",
    "            fractal_dimensions.append(fractal_dim)\n",
    "        \n",
    "        patch_metrics[class_id] = {\n",
    "            'num_patches': num_patches,\n",
    "            'total_area': total_area,\n",
    "            'mean_area': mean_area,\n",
    "            'std_area': std_area,\n",
    "            'min_area': min_area,\n",
    "            'max_area': max_area,\n",
    "            'patch_areas': patch_areas,\n",
    "            'mean_perimeter': np.mean(perimeters),\n",
    "            'mean_shape_index': np.mean(shape_indices),\n",
    "            'mean_fractal_dimension': np.mean(fractal_dimensions)\n",
    "        }\n",
    "    \n",
    "    return patch_metrics\n",
    "\n",
    "patch_analysis = analyze_patches(final_classification_map)\n",
    "\n",
    "print(\"斑块特征分析结果:\")\n",
    "print(\"=\" * 80)\n",
    "print(f\"{'类别':<12} {'斑块数':<8} {'总面积':<10} {'平均面积':<10} {'标准差':<10} {'形状指数':<10}\")\n",
    "print(\"=\" * 80)\n",
    "\n",
    "for class_id in range(len(class_names)):\n",
    "    metrics = patch_analysis[class_id]\n",
    "    print(f\"{class_names[class_id]:<12} {metrics['num_patches']:<8} \"\n",
    "          f\"{metrics['total_area']:<10} {metrics['mean_area']:<10.1f} \"\n",
    "          f\"{metrics['std_area']:<10.1f} {metrics['mean_shape_index']:<10.2f}\")\n",
    "\n",
    "print(\"=\" * 80)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 可视化斑块特征\n",
    "fig, axes = plt.subplots(2, 3, figsize=(18, 12))\n",
    "axes = axes.flatten()\n",
    "\n",
    "# 1. 斑块数量对比\n",
    "patch_nums = [patch_analysis[i]['num_patches'] for i in range(len(class_names))]\n",
    "bars = axes[0].bar(range(len(class_names)), patch_nums, color=colors, alpha=0.8)\n",
    "axes[0].set_xlabel('类别')\n",
    "axes[0].set_ylabel('斑块数量')\n",
    "axes[0].set_title('各类别斑块数量')\n",
    "axes[0].set_xticks(range(len(class_names)))\n",
    "axes[0].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[0].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, num in zip(bars, patch_nums):\n",
    "    axes[0].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(patch_nums)*0.01, \n",
    "                str(num), ha='center', va='bottom')\n",
    "\n",
    "# 2. 平均斑块面积对比\n",
    "mean_areas = [patch_analysis[i]['mean_area'] for i in range(len(class_names))]\n",
    "bars = axes[1].bar(range(len(class_names)), mean_areas, color=colors, alpha=0.8)\n",
    "axes[1].set_xlabel('类别')\n",
    "axes[1].set_ylabel('平均面积 (像素)')\n",
    "axes[1].set_title('各类别平均斑块面积')\n",
    "axes[1].set_xticks(range(len(class_names)))\n",
    "axes[1].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[1].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, area in zip(bars, mean_areas):\n",
    "    axes[1].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(mean_areas)*0.01, \n",
    "                f'{area:.1f}', ha='center', va='bottom')\n",
    "\n",
    "# 3. 形状指数对比\n",
    "shape_indices = [patch_analysis[i]['mean_shape_index'] for i in range(len(class_names))]\n",
    "bars = axes[2].bar(range(len(class_names)), shape_indices, color=colors, alpha=0.8)\n",
    "axes[2].set_xlabel('类别')\n",
    "axes[2].set_ylabel('平均形状指数')\n",
    "axes[2].set_title('各类别平均形状指数')\n",
    "axes[2].set_xticks(range(len(class_names)))\n",
    "axes[2].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[2].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, si in zip(bars, shape_indices):\n",
    "    axes[2].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(shape_indices)*0.01, \n",
    "                f'{si:.2f}', ha='center', va='bottom')\n",
    "\n",
    "# 4. 斑块面积分布（选择斑块数量最多的类别）\n",
    "max_patches_class = np.argmax(patch_nums)\n",
    "if patch_analysis[max_patches_class]['patch_areas']:\n",
    "    patch_areas = patch_analysis[max_patches_class]['patch_areas']\n",
    "    axes[3].hist(patch_areas, bins=20, alpha=0.7, color=colors[max_patches_class], edgecolor='black')\n",
    "    axes[3].set_xlabel('斑块面积 (像素)')\n",
    "    axes[3].set_ylabel('频次')\n",
    "    axes[3].set_title(f'{class_names[max_patches_class]} 斑块面积分布')\n",
    "    axes[3].grid(True, alpha=0.3)\n",
    "\n",
    "# 5. 斑块密度（单位面积斑块数）\n",
    "patch_densities = []\n",
    "for i in range(len(class_names)):\n",
    "    if basic_metrics['class_areas'][i] > 0:\n",
    "        density = patch_analysis[i]['num_patches'] / basic_metrics['class_areas'][i] * 1000  # 每1000像素的斑块数\n",
    "    else:\n",
    "        density = 0\n",
    "    patch_densities.append(density)\n",
    "\n",
    "bars = axes[4].bar(range(len(class_names)), patch_densities, color=colors, alpha=0.8)\n",
    "axes[4].set_xlabel('类别')\n",
    "axes[4].set_ylabel('斑块密度 (个/1000像素)')\n",
    "axes[4].set_title('各类别斑块密度')\n",
    "axes[4].set_xticks(range(len(class_names)))\n",
    "axes[4].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[4].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, density in zip(bars, patch_densities):\n",
    "    axes[4].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(patch_densities)*0.01, \n",
    "                f'{density:.2f}', ha='center', va='bottom')\n",
    "\n",
    "# 6. 分形维数对比\n",
    "fractal_dims = [patch_analysis[i]['mean_fractal_dimension'] for i in range(len(class_names))]\n",
    "bars = axes[5].bar(range(len(class_names)), fractal_dims, color=colors, alpha=0.8)\n",
    "axes[5].set_xlabel('类别')\n",
    "axes[5].set_ylabel('平均分形维数')\n",
    "axes[5].set_title('各类别平均分形维数')\n",
    "axes[5].set_xticks(range(len(class_names)))\n",
    "axes[5].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[5].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, fd in zip(bars, fractal_dims):\n",
    "    axes[5].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(fractal_dims)*0.01, \n",
    "                f'{fd:.2f}', ha='center', va='bottom')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. 连通性分析"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 景观连通性分析\n",
    "print(\"进行景观连通性分析...\")\n",
    "\n",
    "def analyze_connectivity(class_map):\n",
    "    \"\"\"\n",
    "    分析景观连通性\n",
    "    \"\"\"\n",
    "    connectivity_metrics = {}\n",
    "    \n",
    "    for class_id in range(len(class_names)):\n",
    "        # 创建二值掩码\n",
    "        binary_mask = (class_map == class_id).astype(np.uint8)\n",
    "        \n",
    "        if np.sum(binary_mask) == 0:\n",
    "            connectivity_metrics[class_id] = {\n",
    "                'num_components': 0,\n",
    "                'largest_component_ratio': 0,\n",
    "                'cohesion_index': 0,\n",
    "                'connectivity_index': 0\n",
    "            }\n",
    "            continue\n",
    "        \n",
    "        # 连通组件分析\n",
    "        labeled_components = label(binary_mask, connectivity=2)\n",
    "        num_components = labeled_components.max()\n",
    "        \n",
    "        if num_components == 0:\n",
    "            connectivity_metrics[class_id] = {\n",
    "                'num_components': 0,\n",
    "                'largest_component_ratio': 0,\n",
    "                'cohesion_index': 0,\n",
    "                'connectivity_index': 0\n",
    "            }\n",
    "            continue\n",
    "        \n",
    "        # 各连通组件大小\n",
    "        component_sizes = []\n",
    "        for i in range(1, num_components + 1):\n",
    "            size = np.sum(labeled_components == i)\n",
    "            component_sizes.append(size)\n",
    "        \n",
    "        # 最大连通组件比例\n",
    "        largest_component_ratio = max(component_sizes) / sum(component_sizes) if component_sizes else 0\n",
    "        \n",
    "        # 聚合度指数 (Cohesion Index)\n",
    "        total_perimeter = 0\n",
    "        total_area = sum(component_sizes)\n",
    "        \n",
    "        for i in range(1, num_components + 1):\n",
    "            component_mask = (labeled_components == i)\n",
    "            perimeter = measure.perimeter(component_mask)\n",
    "            total_perimeter += perimeter\n",
    "        \n",
    "        # 修正的聚合度指数\n",
    "        if total_area > 1:\n",
    "            cohesion_index = (1 - total_perimeter / (total_area * np.sqrt(total_area))) * 100\n",
    "        else:\n",
    "            cohesion_index = 0\n",
    "        \n",
    "        # 连通性指数 = 1 - (连通组件数 - 1) / (总像素数 - 1)\n",
    "        if total_area > 1:\n",
    "            connectivity_index = 1 - (num_components - 1) / (total_area - 1)\n",
    "        else:\n",
    "            connectivity_index = 1 if num_components == 1 else 0\n",
    "        \n",
    "        connectivity_metrics[class_id] = {\n",
    "            'num_components': num_components,\n",
    "            'largest_component_ratio': largest_component_ratio,\n",
    "            'cohesion_index': max(0, cohesion_index),  # 确保非负\n",
    "            'connectivity_index': connectivity_index,\n",
    "            'component_sizes': component_sizes\n",
    "        }\n",
    "    \n",
    "    return connectivity_metrics\n",
    "\n",
    "connectivity_analysis = analyze_connectivity(final_classification_map)\n",
    "\n",
    "print(\"连通性分析结果:\")\n",
    "print(\"=\" * 90)\n",
    "print(f\"{'类别':<12} {'连通组件':<10} {'最大组件比例':<12} {'聚合度指数':<12} {'连通性指数':<12}\")\n",
    "print(\"=\" * 90)\n",
    "\n",
    "for class_id in range(len(class_names)):\n",
    "    metrics = connectivity_analysis[class_id]\n",
    "    print(f\"{class_names[class_id]:<12} {metrics['num_components']:<10} \"\n",
    "          f\"{metrics['largest_component_ratio']:<12.3f} {metrics['cohesion_index']:<12.2f} \"\n",
    "          f\"{metrics['connectivity_index']:<12.3f}\")\n",
    "\n",
    "print(\"=\" * 90)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 可视化连通性分析\n",
    "fig, axes = plt.subplots(2, 2, figsize=(15, 12))\n",
    "\n",
    "# 1. 连通组件数量\n",
    "num_components = [connectivity_analysis[i]['num_components'] for i in range(len(class_names))]\n",
    "bars = axes[0, 0].bar(range(len(class_names)), num_components, color=colors, alpha=0.8)\n",
    "axes[0, 0].set_xlabel('类别')\n",
    "axes[0, 0].set_ylabel('连通组件数量')\n",
    "axes[0, 0].set_title('各类别连通组件数量')\n",
    "axes[0, 0].set_xticks(range(len(class_names)))\n",
    "axes[0, 0].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[0, 0].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, num in zip(bars, num_components):\n",
    "    axes[0, 0].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(num_components)*0.01, \n",
    "                   str(num), ha='center', va='bottom')\n",
    "\n",
    "# 2. 最大连通组件比例\n",
    "largest_ratios = [connectivity_analysis[i]['largest_component_ratio'] for i in range(len(class_names))]\n",
    "bars = axes[0, 1].bar(range(len(class_names)), largest_ratios, color=colors, alpha=0.8)\n",
    "axes[0, 1].set_xlabel('类别')\n",
    "axes[0, 1].set_ylabel('最大组件比例')\n",
    "axes[0, 1].set_title('各类别最大连通组件比例')\n",
    "axes[0, 1].set_xticks(range(len(class_names)))\n",
    "axes[0, 1].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[0, 1].set_ylim(0, 1)\n",
    "axes[0, 1].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, ratio in zip(bars, largest_ratios):\n",
    "    axes[0, 1].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.02, \n",
    "                   f'{ratio:.3f}', ha='center', va='bottom')\n",
    "\n",
    "# 3. 聚合度指数\n",
    "cohesion_indices = [connectivity_analysis[i]['cohesion_index'] for i in range(len(class_names))]\n",
    "bars = axes[1, 0].bar(range(len(class_names)), cohesion_indices, color=colors, alpha=0.8)\n",
    "axes[1, 0].set_xlabel('类别')\n",
    "axes[1, 0].set_ylabel('聚合度指数')\n",
    "axes[1, 0].set_title('各类别聚合度指数')\n",
    "axes[1, 0].set_xticks(range(len(class_names)))\n",
    "axes[1, 0].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[1, 0].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, cohesion in zip(bars, cohesion_indices):\n",
    "    axes[1, 0].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(cohesion_indices)*0.01, \n",
    "                   f'{cohesion:.2f}', ha='center', va='bottom')\n",
    "\n",
    "# 4. 连通性指数\n",
    "connectivity_indices = [connectivity_analysis[i]['connectivity_index'] for i in range(len(class_names))]\n",
    "bars = axes[1, 1].bar(range(len(class_names)), connectivity_indices, color=colors, alpha=0.8)\n",
    "axes[1, 1].set_xlabel('类别')\n",
    "axes[1, 1].set_ylabel('连通性指数')\n",
    "axes[1, 1].set_title('各类别连通性指数')\n",
    "axes[1, 1].set_xticks(range(len(class_names)))\n",
    "axes[1, 1].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[1, 1].set_ylim(0, 1)\n",
    "axes[1, 1].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, conn in zip(bars, connectivity_indices):\n",
    "    axes[1, 1].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.02, \n",
    "                   f'{conn:.3f}', ha='center', va='bottom')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. 边缘效应分析"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 边缘效应分析\n",
    "print(\"进行边缘效应分析...\")\n",
    "\n",
    "def analyze_edge_effects(class_map):\n",
    "    \"\"\"\n",
    "    分析边缘效应\n",
    "    \"\"\"\n",
    "    edge_metrics = {}\n",
    "    \n",
    "    # 计算总边缘长度\n",
    "    total_edge_length = 0\n",
    "    edge_density_map = np.zeros_like(class_map, dtype=float)\n",
    "    \n",
    "    # 边缘类型统计\n",
    "    edge_types = {}\n",
    "    \n",
    "    for i in range(class_map.shape[0] - 1):\n",
    "        for j in range(class_map.shape[1] - 1):\n",
    "            # 检查右边和下边的邻接\n",
    "            current = class_map[i, j]\n",
    "            right = class_map[i, j + 1]\n",
    "            down = class_map[i + 1, j]\n",
    "            \n",
    "            # 水平边缘\n",
    "            if current != right:\n",
    "                total_edge_length += 1\n",
    "                edge_density_map[i, j] += 0.5\n",
    "                edge_density_map[i, j + 1] += 0.5\n",
    "                \n",
    "                # 记录边缘类型\n",
    "                edge_type = tuple(sorted([current, right]))\n",
    "                edge_types[edge_type] = edge_types.get(edge_type, 0) + 1\n",
    "            \n",
    "            # 垂直边缘\n",
    "            if current != down:\n",
    "                total_edge_length += 1\n",
    "                edge_density_map[i, j] += 0.5\n",
    "                edge_density_map[i + 1, j] += 0.5\n",
    "                \n",
    "                # 记录边缘类型\n",
    "                edge_type = tuple(sorted([current, down]))\n",
    "                edge_types[edge_type] = edge_types.get(edge_type, 0) + 1\n",
    "    \n",
    "    # 各类别边缘分析\n",
    "    for class_id in range(len(class_names)):\n",
    "        class_mask = (class_map == class_id)\n",
    "        \n",
    "        if np.sum(class_mask) == 0:\n",
    "            edge_metrics[class_id] = {\n",
    "                'edge_length': 0,\n",
    "                'edge_density': 0,\n",
    "                'interior_area': 0,\n",
    "                'edge_area': 0,\n",
    "                'core_area_ratio': 0\n",
    "            }\n",
    "            continue\n",
    "        \n",
    "        # 计算该类别的边缘像素\n",
    "        edge_pixels = np.zeros_like(class_mask, dtype=bool)\n",
    "        \n",
    "        # 使用形态学梯度检测边缘\n",
    "        kernel = np.ones((3, 3), dtype=np.uint8)\n",
    "        eroded = morphology.binary_erosion(class_mask, kernel)\n",
    "        edge_pixels = class_mask & ~eroded\n",
    "        \n",
    "        # 计算核心区域（距边缘一定距离的区域）\n",
    "        core_distance = 2  # 距边缘的最小距离\n",
    "        core_kernel = disk(core_distance)\n",
    "        core_area = morphology.binary_erosion(class_mask, core_kernel)\n",
    "        \n",
    "        # 边缘统计\n",
    "        edge_length = np.sum(edge_pixels)\n",
    "        edge_area = np.sum(edge_pixels)\n",
    "        interior_area = np.sum(core_area)\n",
    "        total_class_area = np.sum(class_mask)\n",
    "        \n",
    "        edge_density = edge_length / total_class_area if total_class_area > 0 else 0\n",
    "        core_area_ratio = interior_area / total_class_area if total_class_area > 0 else 0\n",
    "        \n",
    "        edge_metrics[class_id] = {\n",
    "            'edge_length': edge_length,\n",
    "            'edge_density': edge_density,\n",
    "            'interior_area': interior_area,\n",
    "            'edge_area': edge_area,\n",
    "            'core_area_ratio': core_area_ratio\n",
    "        }\n",
    "    \n",
    "    return edge_metrics, edge_density_map, edge_types, total_edge_length\n",
    "\n",
    "edge_analysis, edge_density_map, edge_types, total_edge_length = analyze_edge_effects(final_classification_map)\n",
    "\n",
    "print(\"边缘效应分析结果:\")\n",
    "print(f\"总边缘长度: {total_edge_length} 像素\")\n",
    "print(f\"边缘密度: {total_edge_length / final_classification_map.size:.4f} (边缘/总面积)\")\n",
    "\n",
    "print(\"\\n各类别边缘特征:\")\n",
    "print(\"=\" * 80)\n",
    "print(f\"{'类别':<12} {'边缘长度':<10} {'边缘密度':<10} {'核心区比例':<12} {'边缘区面积':<12}\")\n",
    "print(\"=\" * 80)\n",
    "\n",
    "for class_id in range(len(class_names)):\n",
    "    metrics = edge_analysis[class_id]\n",
    "    print(f\"{class_names[class_id]:<12} {metrics['edge_length']:<10} \"\n",
    "          f\"{metrics['edge_density']:<10.3f} {metrics['core_area_ratio']:<12.3f} \"\n",
    "          f\"{metrics['edge_area']:<12}\")\n",
    "\n",
    "print(\"=\" * 80)\n",
    "\n",
    "# 主要边缘类型\n",
    "print(\"\\n主要边缘类型（前5位）:\")\n",
    "sorted_edge_types = sorted(edge_types.items(), key=lambda x: x[1], reverse=True)\n",
    "for i, ((class1, class2), length) in enumerate(sorted_edge_types[:5]):\n",
    "    percentage = length / total_edge_length * 100\n",
    "    print(f\"{i+1}. {class_names[class1]} - {class_names[class2]}: {length} 像素 ({percentage:.1f}%)\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 可视化边缘效应分析\n",
    "fig, axes = plt.subplots(2, 3, figsize=(18, 12))\n",
    "axes = axes.flatten()\n",
    "\n",
    "# 1. 边缘密度图\n",
    "im1 = axes[0].imshow(edge_density_map, cmap='hot')\n",
    "axes[0].set_title('边缘密度分布图')\n",
    "axes[0].axis('off')\n",
    "plt.colorbar(im1, ax=axes[0], fraction=0.046, pad=0.04, label='边缘密度')\n",
    "\n",
    "# 2. 各类别边缘密度对比\n",
    "edge_densities = [edge_analysis[i]['edge_density'] for i in range(len(class_names))]\n",
    "bars = axes[1].bar(range(len(class_names)), edge_densities, color=colors, alpha=0.8)\n",
    "axes[1].set_xlabel('类别')\n",
    "axes[1].set_ylabel('边缘密度')\n",
    "axes[1].set_title('各类别边缘密度')\n",
    "axes[1].set_xticks(range(len(class_names)))\n",
    "axes[1].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[1].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, density in zip(bars, edge_densities):\n",
    "    axes[1].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(edge_densities)*0.01, \n",
    "                f'{density:.3f}', ha='center', va='bottom')\n",
    "\n",
    "# 3. 核心区域比例\n",
    "core_ratios = [edge_analysis[i]['core_area_ratio'] for i in range(len(class_names))]\n",
    "bars = axes[2].bar(range(len(class_names)), core_ratios, color=colors, alpha=0.8)\n",
    "axes[2].set_xlabel('类别')\n",
    "axes[2].set_ylabel('核心区域比例')\n",
    "axes[2].set_title('各类别核心区域比例')\n",
    "axes[2].set_xticks(range(len(class_names)))\n",
    "axes[2].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[2].set_ylim(0, 1)\n",
    "axes[2].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, ratio in zip(bars, core_ratios):\n",
    "    axes[2].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.02, \n",
    "                f'{ratio:.3f}', ha='center', va='bottom')\n",
    "\n",
    "# 4. 边缘类型分布饼图\n",
    "if len(sorted_edge_types) > 0:\n",
    "    top_edge_types = sorted_edge_types[:8]  # 取前8个主要边缘类型\n",
    "    labels = [f\"{class_names[t[0][0]]}-{class_names[t[0][1]]}\" for t in top_edge_types]\n",
    "    sizes = [t[1] for t in top_edge_types]\n",
    "    \n",
    "    axes[3].pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)\n",
    "    axes[3].set_title('主要边缘类型分布')\n",
    "\n",
    "# 5. 边缘-内部面积比\n",
    "edge_interior_ratios = []\n",
    "for i in range(len(class_names)):\n",
    "    if edge_analysis[i]['interior_area'] > 0:\n",
    "        ratio = edge_analysis[i]['edge_area'] / edge_analysis[i]['interior_area']\n",
    "    else:\n",
    "        ratio = float('inf') if edge_analysis[i]['edge_area'] > 0 else 0\n",
    "    edge_interior_ratios.append(min(ratio, 10))  # 限制最大值以便可视化\n",
    "\n",
    "bars = axes[4].bar(range(len(class_names)), edge_interior_ratios, color=colors, alpha=0.8)\n",
    "axes[4].set_xlabel('类别')\n",
    "axes[4].set_ylabel('边缘/内部面积比')\n",
    "axes[4].set_title('各类别边缘内部面积比')\n",
    "axes[4].set_xticks(range(len(class_names)))\n",
    "axes[4].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[4].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, ratio in zip(bars, edge_interior_ratios):\n",
    "    if ratio == float('inf'):\n",
    "        text = '∞'\n",
    "    else:\n",
    "        text = f'{ratio:.2f}'\n",
    "    axes[4].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(edge_interior_ratios)*0.01, \n",
    "                text, ha='center', va='bottom')\n",
    "\n",
    "# 6. 空白或其他分析\n",
    "axes[5].axis('off')\n",
    "axes[5].text(0.5, 0.5, f'总边缘长度:\\n{total_edge_length} 像素\\n\\n'\n",
    "                      f'平均边缘密度:\\n{total_edge_length / final_classification_map.size:.4f}\\n\\n'\n",
    "                      f'边缘类型数量:\\n{len(edge_types)} 种', \n",
    "            transform=axes[5].transAxes, fontsize=14, \n",
    "            verticalalignment='center', horizontalalignment='center',\n",
    "            bbox=dict(boxstyle='round', facecolor='lightgray', alpha=0.8))\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. 破碎化评估"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 景观破碎化评估\n",
    "print(\"进行景观破碎化评估...\")\n",
    "\n",
    "def assess_fragmentation(class_map, patch_metrics, connectivity_metrics):\n",
    "    \"\"\"\n",
    "    评估景观破碎化程度\n",
    "    \"\"\"\n",
    "    fragmentation_metrics = {}\n",
    "    \n",
    "    for class_id in range(len(class_names)):\n",
    "        patch_data = patch_metrics[class_id]\n",
    "        connectivity_data = connectivity_metrics[class_id]\n",
    "        \n",
    "        if patch_data['total_area'] == 0:\n",
    "            fragmentation_metrics[class_id] = {\n",
    "                'fragmentation_index': 0,\n",
    "                'subdivision_index': 0,\n",
    "                'isolation_index': 0,\n",
    "                'aggregation_index': 0,\n",
    "                'effective_mesh_size': 0\n",
    "            }\n",
    "            continue\n",
    "        \n",
    "        # 1. 破碎化指数 = 斑块数 / 总面积\n",
    "        fragmentation_index = patch_data['num_patches'] / patch_data['total_area'] * 1000\n",
    "        \n",
    "        # 2. 细分指数 = 连通组件数 / 总面积\n",
    "        subdivision_index = connectivity_data['num_components'] / patch_data['total_area'] * 1000\n",
    "        \n",
    "        # 3. 隔离指数 = 1 - 最大连通组件比例\n",
    "        isolation_index = 1 - connectivity_data['largest_component_ratio']\n",
    "        \n",
    "        # 4. 聚集指数 = 聚合度指数\n",
    "        aggregation_index = connectivity_data['cohesion_index']\n",
    "        \n",
    "        # 5. 有效网格大小 (基于最大斑块面积)\n",
    "        if patch_data['patch_areas']:\n",
    "            max_patch_area = max(patch_data['patch_areas'])\n",
    "            effective_mesh_size = (max_patch_area ** 2) / patch_data['total_area']\n",
    "        else:\n",
    "            effective_mesh_size = 0\n",
    "        \n",
    "        fragmentation_metrics[class_id] = {\n",
    "            'fragmentation_index': fragmentation_index,\n",
    "            'subdivision_index': subdivision_index,\n",
    "            'isolation_index': isolation_index,\n",
    "            'aggregation_index': aggregation_index,\n",
    "            'effective_mesh_size': effective_mesh_size\n",
    "        }\n",
    "    \n",
    "    # 计算综合破碎化指数\n",
    "    overall_fragmentation = {}\n",
    "    \n",
    "    # 加权平均（按面积加权）\n",
    "    total_landscape_area = sum(patch_metrics[i]['total_area'] for i in range(len(class_names)))\n",
    "    \n",
    "    weighted_fragmentation = 0\n",
    "    weighted_isolation = 0\n",
    "    \n",
    "    for class_id in range(len(class_names)):\n",
    "        if total_landscape_area > 0:\n",
    "            weight = patch_metrics[class_id]['total_area'] / total_landscape_area\n",
    "            weighted_fragmentation += fragmentation_metrics[class_id]['fragmentation_index'] * weight\n",
    "            weighted_isolation += fragmentation_metrics[class_id]['isolation_index'] * weight\n",
    "    \n",
    "    overall_fragmentation = {\n",
    "        'landscape_fragmentation_index': weighted_fragmentation,\n",
    "        'landscape_isolation_index': weighted_isolation,\n",
    "        'total_patches': sum(patch_metrics[i]['num_patches'] for i in range(len(class_names))),\n",
    "        'patch_density': sum(patch_metrics[i]['num_patches'] for i in range(len(class_names))) / total_landscape_area * 1000\n",
    "    }\n",
    "    \n",
    "    return fragmentation_metrics, overall_fragmentation\n",
    "\n",
    "fragmentation_analysis, overall_fragmentation = assess_fragmentation(\n",
    "    final_classification_map, patch_analysis, connectivity_analysis\n",
    ")\n",
    "\n",
    "print(\"破碎化评估结果:\")\n",
    "print(\"=\" * 100)\n",
    "print(f\"{'类别':<12} {'破碎化指数':<12} {'细分指数':<10} {'隔离指数':<10} {'聚集指数':<10} {'有效网格':<10}\")\n",
    "print(\"=\" * 100)\n",
    "\n",
    "for class_id in range(len(class_names)):\n",
    "    metrics = fragmentation_analysis[class_id]\n",
    "    print(f\"{class_names[class_id]:<12} {metrics['fragmentation_index']:<12.2f} \"\n",
    "          f\"{metrics['subdivision_index']:<10.2f} {metrics['isolation_index']:<10.3f} \"\n",
    "          f\"{metrics['aggregation_index']:<10.2f} {metrics['effective_mesh_size']:<10.1f}\")\n",
    "\n",
    "print(\"=\" * 100)\n",
    "\n",
    "print(f\"\\n整体景观破碎化指标:\")\n",
    "print(f\"景观破碎化指数: {overall_fragmentation['landscape_fragmentation_index']:.3f}\")\n",
    "print(f\"景观隔离指数: {overall_fragmentation['landscape_isolation_index']:.3f}\")\n",
    "print(f\"总斑块数: {overall_fragmentation['total_patches']}\")\n",
    "print(f\"斑块密度: {overall_fragmentation['patch_density']:.3f} 个/1000像素\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 可视化破碎化分析\n",
    "fig, axes = plt.subplots(2, 3, figsize=(18, 12))\n",
    "axes = axes.flatten()\n",
    "\n",
    "# 1. 破碎化指数\n",
    "frag_indices = [fragmentation_analysis[i]['fragmentation_index'] for i in range(len(class_names))]\n",
    "bars = axes[0].bar(range(len(class_names)), frag_indices, color=colors, alpha=0.8)\n",
    "axes[0].set_xlabel('类别')\n",
    "axes[0].set_ylabel('破碎化指数')\n",
    "axes[0].set_title('各类别破碎化指数')\n",
    "axes[0].set_xticks(range(len(class_names)))\n",
    "axes[0].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[0].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, idx in zip(bars, frag_indices):\n",
    "    axes[0].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(frag_indices)*0.01, \n",
    "                f'{idx:.2f}', ha='center', va='bottom')\n",
    "\n",
    "# 2. 隔离指数\n",
    "isolation_indices = [fragmentation_analysis[i]['isolation_index'] for i in range(len(class_names))]\n",
    "bars = axes[1].bar(range(len(class_names)), isolation_indices, color=colors, alpha=0.8)\n",
    "axes[1].set_xlabel('类别')\n",
    "axes[1].set_ylabel('隔离指数')\n",
    "axes[1].set_title('各类别隔离指数')\n",
    "axes[1].set_xticks(range(len(class_names)))\n",
    "axes[1].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[1].set_ylim(0, 1)\n",
    "axes[1].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, idx in zip(bars, isolation_indices):\n",
    "    axes[1].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.02, \n",
    "                f'{idx:.3f}', ha='center', va='bottom')\n",
    "\n",
    "# 3. 聚集指数\n",
    "aggregation_indices = [fragmentation_analysis[i]['aggregation_index'] for i in range(len(class_names))]\n",
    "bars = axes[2].bar(range(len(class_names)), aggregation_indices, color=colors, alpha=0.8)\n",
    "axes[2].set_xlabel('类别')\n",
    "axes[2].set_ylabel('聚集指数')\n",
    "axes[2].set_title('各类别聚集指数')\n",
    "axes[2].set_xticks(range(len(class_names)))\n",
    "axes[2].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[2].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, idx in zip(bars, aggregation_indices):\n",
    "    axes[2].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(aggregation_indices)*0.01, \n",
    "                f'{idx:.2f}', ha='center', va='bottom')\n",
    "\n",
    "# 4. 有效网格大小\n",
    "mesh_sizes = [fragmentation_analysis[i]['effective_mesh_size'] for i in range(len(class_names))]\n",
    "bars = axes[3].bar(range(len(class_names)), mesh_sizes, color=colors, alpha=0.8)\n",
    "axes[3].set_xlabel('类别')\n",
    "axes[3].set_ylabel('有效网格大小')\n",
    "axes[3].set_title('各类别有效网格大小')\n",
    "axes[3].set_xticks(range(len(class_names)))\n",
    "axes[3].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[3].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, size in zip(bars, mesh_sizes):\n",
    "    axes[3].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(mesh_sizes)*0.01, \n",
    "                f'{size:.1f}', ha='center', va='bottom')\n",
    "\n",
    "# 5. 破碎化vs聚集度散点图\n",
    "axes[4].scatter(frag_indices, aggregation_indices, c=colors[:len(class_names)], s=100, alpha=0.8)\n",
    "axes[4].set_xlabel('破碎化指数')\n",
    "axes[4].set_ylabel('聚集指数')\n",
    "axes[4].set_title('破碎化vs聚集度关系')\n",
    "axes[4].grid(True, alpha=0.3)\n",
    "\n",
    "# 添加类别标签\n",
    "for i, (x, y) in enumerate(zip(frag_indices, aggregation_indices)):\n",
    "    axes[4].annotate(class_names[i][:4], (x, y), xytext=(5, 5), \n",
    "                    textcoords='offset points', fontsize=8)\n",
    "\n",
    "# 6. 综合破碎化评估雷达图\n",
    "metrics_names = ['破碎化', '隔离度', '聚集度']\n",
    "metrics_values = [\n",
    "    overall_fragmentation['landscape_fragmentation_index'] / max(frag_indices) if max(frag_indices) > 0 else 0,\n",
    "    overall_fragmentation['landscape_isolation_index'],\n",
    "    np.mean(aggregation_indices) / 100 if max(aggregation_indices) > 0 else 0\n",
    "]\n",
    "\n",
    "# 标准化到0-1范围\n",
    "metrics_values = [min(1, max(0, v)) for v in metrics_values]\n",
    "\n",
    "angles = np.linspace(0, 2 * np.pi, len(metrics_names), endpoint=False)\n",
    "metrics_values += metrics_values[:1]  # 闭合图形\n",
    "angles = np.concatenate((angles, [angles[0]]))\n",
    "\n",
    "axes[5].plot(angles, metrics_values, 'o-', linewidth=2, color='red', alpha=0.8)\n",
    "axes[5].fill(angles, metrics_values, alpha=0.25, color='red')\n",
    "axes[5].set_xticks(angles[:-1])\n",
    "axes[5].set_xticklabels(metrics_names)\n",
    "axes[5].set_ylim(0, 1)\n",
    "axes[5].set_title('景观破碎化综合评估')\n",
    "axes[5].grid(True)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. 生态功能评估"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 生态功能评估\n",
    "print(\"进行生态功能评估...\")\n",
    "\n",
    "def assess_ecological_functions(class_map, patch_metrics, connectivity_metrics):\n",
    "    \"\"\"\n",
    "    评估景观的生态功能\n",
    "    \"\"\"\n",
    "    # 定义各类别的生态功能权重\n",
    "    ecological_weights = {\n",
    "        0: {  # 开放水面\n",
    "            'habitat_value': 0.8,      # 栖息地价值\n",
    "            'connectivity_value': 0.9,  # 连通性价值\n",
    "            'purification_value': 0.7,  # 净化功能\n",
    "            'regulation_value': 0.8,    # 调节功能\n",
    "            'biodiversity_value': 0.6   # 生物多样性\n",
    "        },\n",
    "        1: {  # 挺水植物\n",
    "            'habitat_value': 0.9,\n",
    "            'connectivity_value': 0.7,\n",
    "            'purification_value': 0.9,\n",
    "            'regulation_value': 0.8,\n",
    "            'biodiversity_value': 0.9\n",
    "        },\n",
    "        2: {  # 浮叶植物\n",
    "            'habitat_value': 0.8,\n",
    "            'connectivity_value': 0.6,\n",
    "            'purification_value': 0.8,\n",
    "            'regulation_value': 0.7,\n",
    "            'biodiversity_value': 0.7\n",
    "        },\n",
    "        3: {  # 湿生草本\n",
    "            'habitat_value': 0.7,\n",
    "            'connectivity_value': 0.8,\n",
    "            'purification_value': 0.6,\n",
    "            'regulation_value': 0.6,\n",
    "            'biodiversity_value': 0.8\n",
    "        },\n",
    "        4: {  # 土壤/裸地\n",
    "            'habitat_value': 0.2,\n",
    "            'connectivity_value': 0.1,\n",
    "            'purification_value': 0.1,\n",
    "            'regulation_value': 0.2,\n",
    "            'biodiversity_value': 0.1\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    ecological_assessment = {}\n",
    "    function_types = ['habitat_value', 'connectivity_value', 'purification_value', \n",
    "                     'regulation_value', 'biodiversity_value']\n",
    "    \n",
    "    total_area = class_map.size\n",
    "    \n",
    "    # 计算各功能的景观总值\n",
    "    landscape_functions = {func: 0 for func in function_types}\n",
    "    \n",
    "    for class_id in range(len(class_names)):\n",
    "        class_area = patch_metrics[class_id]['total_area']\n",
    "        class_prop = class_area / total_area\n",
    "        \n",
    "        # 计算该类别的生态功能值\n",
    "        class_functions = {}\n",
    "        \n",
    "        for func_type in function_types:\n",
    "            base_value = ecological_weights[class_id][func_type]\n",
    "            \n",
    "            # 根据斑块特征调整功能值\n",
    "            # 连通性调整\n",
    "            connectivity_factor = connectivity_metrics[class_id]['connectivity_index']\n",
    "            \n",
    "            # 斑块大小调整（大斑块功能更强）\n",
    "            if patch_metrics[class_id]['num_patches'] > 0:\n",
    "                avg_patch_size = patch_metrics[class_id]['mean_area']\n",
    "                size_factor = min(1.2, 1 + np.log10(avg_patch_size + 1) / 10)\n",
    "            else:\n",
    "                size_factor = 0\n",
    "            \n",
    "            # 形状调整（规则形状功能更强）\n",
    "            shape_factor = max(0.5, 1 - (patch_metrics[class_id]['mean_shape_index'] - 1) / 5)\n",
    "            \n",
    "            # 综合调整\n",
    "            adjusted_value = base_value * connectivity_factor * size_factor * shape_factor\n",
    "            class_functions[func_type] = adjusted_value\n",
    "            \n",
    "            # 累加到景观总功能\n",
    "            landscape_functions[func_type] += adjusted_value * class_prop\n",
    "        \n",
    "        ecological_assessment[class_id] = class_functions\n",
    "    \n",
    "    # 计算综合生态功能指数\n",
    "    comprehensive_index = sum(landscape_functions.values()) / len(function_types)\n",
    "    \n",
    "    # 生态系统服务价值评估\n",
    "    ecosystem_services = {\n",
    "        '栖息地供给': landscape_functions['habitat_value'],\n",
    "        '景观连通性': landscape_functions['connectivity_value'], \n",
    "        '水质净化': landscape_functions['purification_value'],\n",
    "        '气候调节': landscape_functions['regulation_value'],\n",
    "        '生物多样性维持': landscape_functions['biodiversity_value'],\n",
    "        '综合功能指数': comprehensive_index\n",
    "    }\n",
    "    \n",
    "    return ecological_assessment, landscape_functions, ecosystem_services\n",
    "\n",
    "ecological_assessment, landscape_functions, ecosystem_services = assess_ecological_functions(\n",
    "    final_classification_map, patch_analysis, connectivity_analysis\n",
    ")\n",
    "\n",
    "print(\"生态功能评估结果:\")\n",
    "print(\"=\" * 90)\n",
    "print(f\"{'类别':<12} {'栖息地':<8} {'连通性':<8} {'净化':<8} {'调节':<8} {'多样性':<8}\")\n",
    "print(\"=\" * 90)\n",
    "\n",
    "for class_id in range(len(class_names)):\n",
    "    functions = ecological_assessment[class_id]\n",
    "    print(f\"{class_names[class_id]:<12} {functions['habitat_value']:<8.3f} \"\n",
    "          f\"{functions['connectivity_value']:<8.3f} {functions['purification_value']:<8.3f} \"\n",
    "          f\"{functions['regulation_value']:<8.3f} {functions['biodiversity_value']:<8.3f}\")\n",
    "\n",
    "print(\"=\" * 90)\n",
    "\n",
    "print(f\"\\n景观生态系统服务功能:\")\n",
    "for service, value in ecosystem_services.items():\n",
    "    print(f\"{service}: {value:.3f}\")\n",
    "\n",
    "# 功能等级评价\n",
    "if ecosystem_services['综合功能指数'] >= 0.8:\n",
    "    function_level = \"优秀\"\n",
    "elif ecosystem_services['综合功能指数'] >= 0.6:\n",
    "    function_level = \"良好\"\n",
    "elif ecosystem_services['综合功能指数'] >= 0.4:\n",
    "    function_level = \"中等\"\n",
    "elif ecosystem_services['综合功能指数'] >= 0.2:\n",
    "    function_level = \"较差\"\n",
    "else:\n",
    "    function_level = \"很差\"\n",
    "\n",
    "print(f\"\\n综合生态功能等级: {function_level}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 可视化生态功能评估\n",
    "fig, axes = plt.subplots(2, 2, figsize=(15, 12))\n",
    "\n",
    "# 1. 各类别生态功能雷达图\n",
    "function_names = ['栖息地', '连通性', '净化', '调节', '多样性']\n",
    "function_keys = ['habitat_value', 'connectivity_value', 'purification_value', \n",
    "                'regulation_value', 'biodiversity_value']\n",
    "\n",
    "angles = np.linspace(0, 2 * np.pi, len(function_names), endpoint=False)\n",
    "angles = np.concatenate((angles, [angles[0]]))  # 闭合\n",
    "\n",
    "for class_id in range(min(3, len(class_names))):  # 只显示前3个类别\n",
    "    values = [ecological_assessment[class_id][key] for key in function_keys]\n",
    "    values += values[:1]  # 闭合\n",
    "    \n",
    "    axes[0, 0].plot(angles, values, 'o-', linewidth=2, \n",
    "                   color=colors[class_id], label=class_names[class_id], alpha=0.8)\n",
    "    axes[0, 0].fill(angles, values, alpha=0.25, color=colors[class_id])\n",
    "\n",
    "axes[0, 0].set_xticks(angles[:-1])\n",
    "axes[0, 0].set_xticklabels(function_names)\n",
    "axes[0, 0].set_ylim(0, 1)\n",
    "axes[0, 0].set_title('各类别生态功能对比')\n",
    "axes[0, 0].legend(loc='upper right', bbox_to_anchor=(1.3, 1))\n",
    "axes[0, 0].grid(True)\n",
    "\n",
    "# 2. 景观生态服务功能条形图\n",
    "services = list(ecosystem_services.keys())[:-1]  # 除去综合指数\n",
    "service_values = [ecosystem_services[s] for s in services]\n",
    "\n",
    "bars = axes[0, 1].barh(range(len(services)), service_values, \n",
    "                      color=plt.cm.viridis(np.linspace(0, 1, len(services))), alpha=0.8)\n",
    "axes[0, 1].set_yticks(range(len(services)))\n",
    "axes[0, 1].set_yticklabels(services)\n",
    "axes[0, 1].set_xlabel('功能指数')\n",
    "axes[0, 1].set_title('景观生态系统服务功能')\n",
    "axes[0, 1].set_xlim(0, 1)\n",
    "axes[0, 1].grid(True, alpha=0.3)\n",
    "\n",
    "# 添加数值标签\n",
    "for bar, value in zip(bars, service_values):\n",
    "    axes[0, 1].text(bar.get_width() + 0.01, bar.get_y() + bar.get_height()/2, \n",
    "                   f'{value:.3f}', va='center', fontsize=10)\n",
    "\n",
    "# 3. 面积-功能关系散点图\n",
    "areas = [basic_metrics['class_areas'][i] for i in range(len(class_names))]\n",
    "habitat_values = [ecological_assessment[i]['habitat_value'] for i in range(len(class_names))]\n",
    "\n",
    # 这是06_景观分析.ipynb第7节生态功能评估可视化部分的完整补充

# 统计各类别的功能等级
for class_id in range(len(class_names)):
    area = basic_metrics['class_areas'][class_id]
    if area == 0:
        continue
    
    # 计算该类别的综合功能指数
    class_comprehensive = sum(ecological_assessment[class_id].values()) / len(ecological_assessment[class_id])
    
    if class_comprehensive >= 0.8:
        function_levels['优秀 (≥0.8)'] += area
    elif class_comprehensive >= 0.6:
        function_levels['良好 (0.6-0.8)'] += area
    elif class_comprehensive >= 0.4:
        function_levels['中等 (0.4-0.6)'] += area
    elif class_comprehensive >= 0.2:
        function_levels['较差 (0.2-0.4)'] += area
    else:
        function_levels['很差 (<0.2)'] += area

# 过滤掉面积为0的等级
function_levels = {k: v for k, v in function_levels.items() if v > 0}

if function_levels:
    axes[1, 1].pie(function_levels.values(), labels=function_levels.keys(), 
                   autopct='%1.1f%%', startangle=90,
                   colors=plt.cm.RdYlGn(np.linspace(0.2, 0.8, len(function_levels))))
    axes[1, 1].set_title('生态功能等级面积分布')

plt.tight_layout()
plt.show()

# 生态功能空间分布图
fig, ax = plt.subplots(figsize=(12, 10))

# 计算每个像素的生态功能值
function_map = np.zeros_like(final_classification_map, dtype=float)
for i in range(final_classification_map.shape[0]):
    for j in range(final_classification_map.shape[1]):
        class_id = final_classification_map[i, j]
        # 使用综合功能指数
        function_value = sum(ecological_assessment[class_id].values()) / len(ecological_assessment[class_id])
        function_map[i, j] = function_value

im = ax.imshow(function_map, cmap='RdYlGn', vmin=0, vmax=1)
ax.set_title('湿地生态功能空间分布', fontsize=16, fontweight='bold')
ax.axis('off')

# 添加颜色条
cbar = plt.colorbar(im, ax=ax, fraction=0.046, pad=0.04)
cbar.set_label('生态功能指数', fontsize=12)

# 添加功能等级说明
ax.text(0.02, 0.98, f'综合功能等级: {function_level}\n综合指数: {ecosystem_services["综合功能指数"]:.3f}', 
        transform=ax.transAxes, fontsize=12, fontweight='bold',
        verticalalignment='top', 
        bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

plt.tight_layout()
plt.show()

print(f"\n生态功能评估完成，景观综合功能等级: {function_level}")
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 8. 景观指数综合分析"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 景观指数综合分析\n",
    "print(\"进行景观指数综合分析...\")\n",
    "\n",
    "# 整理所有景观指数\n",
    "landscape_indices = {\n",
    "    '基础指数': {\n",
    "        'Shannon多样性指数': basic_metrics['shannon_diversity'],\n",
    "        'Simpson多样性指数': basic_metrics['simpson_diversity'],\n",
    "        '均匀度指数': basic_metrics['evenness'],\n",
    "        '优势度指数': basic_metrics['dominance']\n",
    "    },\n",
    "    '斑块指数': {\n",
    "        '总斑块数': sum(patch_analysis[i]['num_patches'] for i in range(len(class_names))),\n",
    "        '斑块密度': overall_fragmentation['patch_density'],\n",
    "        '平均斑块面积': np.mean([patch_analysis[i]['mean_area'] for i in range(len(class_names)) if patch_analysis[i]['mean_area'] > 0]),\n",
    "        '最大斑块比例': max([connectivity_analysis[i]['largest_component_ratio'] for i in range(len(class_names))])\n",
    "    },\n",
    "    '形状指数': {\n",
    "        '平均形状指数': np.mean([patch_analysis[i]['mean_shape_index'] for i in range(len(class_names)) if patch_analysis[i]['mean_shape_index'] > 0]),\n",
    "        '平均分形维数': np.mean([patch_analysis[i]['mean_fractal_dimension'] for i in range(len(class_names)) if patch_analysis[i]['mean_fractal_dimension'] > 0])\n",
    "    },\n",
    "    '连通性指数': {\n",
    "        '平均连通性指数': np.mean([connectivity_analysis[i]['connectivity_index'] for i in range(len(class_names))]),\n",
    "        '平均聚合度指数': np.mean([connectivity_analysis[i]['cohesion_index'] for i in range(len(class_names))])\n",
    "    },\n",
    "    '破碎化指数': {\n",
    "        '景观破碎化指数': overall_fragmentation['landscape_fragmentation_index'],\n",
    "        '景观隔离指数': overall_fragmentation['landscape_isolation_index']\n",
    "    },\n",
    "    '边缘指数': {\n",
    "        '总边缘长度': total_edge_length,\n",
    "        '边缘密度': total_edge_length / final_classification_map.size,\n",
    "        '平均核心区比例': np.mean([edge_analysis[i]['core_area_ratio'] for i in range(len(class_names))])\n",
    "    },\n",
    "    '生态功能指数': ecosystem_services\n",
    "}\n",
    "\n",
    "# 景观质量综合评价\n",
    "def evaluate_landscape_quality(indices):\n",
    "    \"\"\"\n",
    "    基于景观指数综合评价景观质量\n",
    "    \"\"\"\n",
    "    quality_scores = {}\n",
    "    \n",
    "    # 多样性评价 (0-1, 越高越好)\n",
    "    diversity_score = min(1, indices['基础指数']['Shannon多样性指数'] / 2)  # 假设最大值为2\n",
    "    quality_scores['多样性'] = diversity_score\n",
    "    \n",
    "    # 连通性评价 (0-1, 越高越好)\n",
    "    connectivity_score = indices['连通性指数']['平均连通性指数']\n",
    "    quality_scores['连通性'] = connectivity_score\n",
    "    \n",
    "    # 破碎化评价 (0-1, 越低越好，需要反转)\n",
    "    fragmentation_score = max(0, 1 - indices['破碎化指数']['景观隔离指数'])\n",
    "    quality_scores['完整性'] = fragmentation_score\n",
    "    \n",
    "    # 边缘效应评价 (0-1, 核心区比例越高越好)\n",
    "    edge_score = indices['边缘指数']['平均核心区比例']\n",
    "    quality_scores['边缘质量'] = edge_score\n",
    "    \n",
    "    # 生态功能评价\n",
    "    ecological_score = indices['生态功能指数']['综合功能指数']\n",
    "    quality_scores['生态功能'] = ecological_score\n",
    "    \n",
    "    # 综合评分\n",
    "    overall_score = sum(quality_scores.values()) / len(quality_scores)\n",
    "    quality_scores['综合评分'] = overall_score\n",
    "    \n",
    "    return quality_scores\n",
    "\n",
    "landscape_quality = evaluate_landscape_quality(landscape_indices)\n",
    "\n",
    "print(\"景观质量评价结果:\")\n",
    "for aspect, score in landscape_quality.items():\n",
    "    if aspect != '综合评分':\n",
    "        print(f\"{aspect}: {score:.3f}\")\n",
    "    else:\n",
    "        print(f\"\\n{aspect}: {score:.3f}\")\n",
    "\n",
    "# 确定景观质量等级\n",
    "overall_score = landscape_quality['综合评分']\n",
    "if overall_score >= 0.8:\n",
    "    quality_level = \"优秀\"\n",
    "elif overall_score >= 0.6:\n",
    "    quality_level = \"良好\"\n",
    "elif overall_score >= 0.4:\n",
    "    quality_level = \"中等\"\n",
    "elif overall_score >= 0.2:\n",
    "    quality_level = \"较差\"\n",
    "else:\n",
    "    quality_level = \"很差\"\n",
    "\n",
    "print(f\"\\n景观质量等级: {quality_level}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 可视化综合分析结果\n",
    "fig, axes = plt.subplots(2, 2, figsize=(15, 12))\n",
    "\n",
    "# 1. 景观质量雷达图\n",
    "quality_aspects = list(landscape_quality.keys())[:-1]  # 除去综合评分\n",
    "quality_values = [landscape_quality[aspect] for aspect in quality_aspects]\n",
    "\n",
    "angles = np.linspace(0, 2 * np.pi, len(quality_aspects), endpoint=False)\n",
    "quality_values += quality_values[:1]  # 闭合\n",
    "angles = np.concatenate((angles, [angles[0]]))\n",
    "\n",
    "axes[0, 0].plot(angles, quality_values, 'o-', linewidth=3, color='blue', alpha=0.8)\n",
    "axes[0, 0].fill(angles, quality_values, alpha=0.25, color='blue')\n",
    "axes[0, 0].set_xticks(angles[:-1])\n",
    "axes[0, 0].set_xticklabels(quality_aspects, fontsize=10)\n",
    "axes[0, 0].set_ylim(0, 1)\n",
    "axes[0, 0].set_title(f'景观质量综合评价\\n等级: {quality_level}', fontsize=14, fontweight='bold')\n",
    "axes[0, 0].grid(True)\n",
    "\n",
    "# 2. 主要景观指数对比\n",
    "key_indices = {\n",
    "    'Shannon多样性': landscape_indices['基础指数']['Shannon多样性指数'],\n",
    "    '连通性指数': landscape_indices['连通性指数']['平均连通性指数'],\n",
    "    '破碎化指数': landscape_indices['破碎化指数']['景观破碎化指数'] / 10,  # 标准化\n",
    "    '边缘密度': landscape_indices['边缘指数']['边缘密度'] * 10,  # 放大显示\n",
    "    '生态功能': landscape_indices['生态功能指数']['综合功能指数']\n",
    "}\n",
    "\n",
    "index_names = list(key_indices.keys())\n",
    "index_values = list(key_indices.values())\n",
    "\n",
    "bars = axes[0, 1].bar(range(len(index_names)), index_values, \n",
    "                     color=plt.cm.viridis(np.linspace(0, 1, len(index_names))), alpha=0.8)\n",
    "axes[0, 1].set_xlabel('景观指数')\n",
    "axes[0, 1].set_ylabel('指数值')\n",
    "axes[0, 1].set_title('主要景观指数')\n",
    "axes[0, 1].set_xticks(range(len(index_names)))\n",
    "axes[0, 1].set_xticklabels(index_names, rotation=45)\n",
    "axes[0, 1].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, value in zip(bars, index_values):\n",
    "    axes[0, 1].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(index_values)*0.01, \n",
    "                   f'{value:.3f}', ha='center', va='bottom', fontsize=9)\n",
    "\n",
    "# 3. 各类别综合表现\n",
    "class_performance = []\n",
    "for class_id in range(len(class_names)):\n",
    "    # 综合考虑面积、连通性、形状、生态功能\n",
    "    area_score = min(1, basic_metrics['class_proportions'][class_id] * 5)  # 标准化面积比例\n",
    "    connectivity_score = connectivity_analysis[class_id]['connectivity_index']\n",
    "    shape_score = max(0, 1 - (patch_analysis[class_id]['mean_shape_index'] - 1) / 3)\n",
    "    ecological_score = sum(ecological_assessment[class_id].values()) / len(ecological_assessment[class_id])\n",
    "    \n",
    "    comprehensive_score = (area_score + connectivity_score + shape_score + ecological_score) / 4\n",
    "    class_performance.append(comprehensive_score)\n",
    "\n",
    "bars = axes[1, 0].bar(range(len(class_names)), class_performance, color=colors, alpha=0.8)\n",
    "axes[1, 0].set_xlabel('类别')\n",
    "axes[1, 0].set_ylabel('综合表现分数')\n",
    "axes[1, 0].set_title('各类别综合表现')\n",
    "axes[1, 0].set_xticks(range(len(class_names)))\n",
    "axes[1, 0].set_xticklabels([class_names[i] for i in range(len(class_names))], rotation=45)\n",
    "axes[1, 0].set_ylim(0, 1)\n",
    "axes[1, 0].grid(True, alpha=0.3)\n",
    "\n",
    "for bar, score in zip(bars, class_performance):\n",
    "    axes[1, 0].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.02, \n",
    "                   f'{score:.3f}', ha='center', va='bottom')\n",
    "\n",
    "# 4. 景观演化趋势预测（简化版）\n",
    "# 基于当前指数预测可能的变化趋势\n",
    "trend_factors = {\n",
    "    '多样性趋势': 'stable' if landscape_indices['基础指数']['均匀度指数'] > 0.7 else 'declining',\n",
    "    '连通性趋势': 'improving' if landscape_indices['连通性指数']['平均连通性指数'] > 0.6 else 'declining',\n",
    "    '破碎化趋势': 'worsening' if landscape_indices['破碎化指数']['景观隔离指数'] > 0.5 else 'stable',\n",
    "    '生态功能趋势': 'stable' if ecosystem_services['综合功能指数'] > 0.6 else 'declining'\n",
    "}\n",
    "\n",
    "trend_colors = {'improving': 'green', 'stable': 'orange', 'declining': 'red', 'worsening': 'darkred'}\n",
    "trend_labels = list(trend_factors.keys())\n",
    "trend_status = list(trend_factors.values())\n",
    "colors_list = [trend_colors[status] for status in trend_status]\n",
    "\n",
    "y_pos = np.arange(len(trend_labels))\n",
    "bars = axes[1, 1].barh(y_pos, [1]*len(trend_labels), color=colors_list, alpha=0.7)\n",
    "axes[1, 1].set_yticks(y_pos)\n",
    "axes[1, 1].set_yticklabels([label.replace('趋势', '') for label in trend_labels])\n",
    "axes[1, 1].set_xlabel('趋势状态')\n",
    "axes[1, 1].set_title('景观演化趋势预测')\n",
    "axes[1, 1].set_xlim(0, 1)\n",
    "\n",
    "# 添加状态标签\n",
    "for bar, status in zip(bars, trend_status):\n",
    "    axes[1, 1].text(bar.get_width()/2, bar.get_y() + bar.get_height()/2, \n",
    "                   status.replace('_', ' ').title(), ha='center', va='center', \n",
    "                   fontweight='bold', color='white')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 9. 结果保存和报告生成"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 保存景观分析结果\n",
    "print(\"保存景观分析结果...\")\n",
    "\n",
    "# 保存主要图表\n",
    "# 1. 保存景观分类图和功能分布图\n",
    "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 8))\n",
    "\n",
    "# 分类图\n",
    "colors = [class_colors[i] for i in range(len(class_names))]\n",
    "cmap = plt.matplotlib.colors.ListedColormap(colors)\n",
    "im1 = ax1.imshow(final_classification_map, cmap=cmap, vmin=0, vmax=len(class_names)-1)\n",
    "ax1.set_title('湿地景观分类图', fontsize=16, fontweight='bold')\n",
    "ax1.axis('off')\n",
    "\n",
    "# 添加图例\n",
    "legend_elements = [plt.matplotlib.patches.Patch(color=colors[i], label=class_names[i]) \n",
    "                  for i in range(len(class_names))]\n",
    "ax1.legend(handles=legend_elements, loc='center left', bbox_to_anchor=(1, 0.5), fontsize=12)\n",
    "\n",
    "# 生态功能分布图\n",
    "im2 = ax2.imshow(function_map, cmap='RdYlGn', vmin=0, vmax=1)\n",
    "ax2.set_title('生态功能分布图', fontsize=16, fontweight='bold')\n",
    "ax2.axis('off')\n",
    "\n",
    "# 添加颜色条\n",
    "cbar = plt.colorbar(im2, ax=ax2, fraction=0.046, pad=0.04)\n",
    "cbar.set_label('生态功能指数', fontsize=12)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.savefig(landscape_dir / 'landscape_analysis_overview.png', dpi=300, bbox_inches='tight')\n",
    "plt.savefig(landscape_dir / 'landscape_analysis_overview.pdf', bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "print(f\"景观分析概览图已保存到: {landscape_dir}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 生成景观分析综合报告\n",
    "landscape_report = {\n",
    "    '基本信息': {\n",
    "        '分析区域': '湿地生态系统',\n",
    "        '影像尺寸': f\"{img_height} × {img_width} 像素\",\n",
    "        '总面积': int(final_classification_map.size),\n",
    "        '类别数量': len(class_names),\n",
    "        '分析日期': pd.Timestamp.now().strftime('%Y-%m-%d')\n",
    "    },\n",
    "    '类别统计': {\n",
    "        class_names[i]: {\n",
    "            '面积_像素': int(basic_metrics['class_areas'][i]),\n",
    "            '面积比例': float(basic_metrics['class_proportions'][i]),\n",
    "            '斑块数量': int(patch_analysis[i]['num_patches']),\n",
    "            '平均斑块面积': float(patch_analysis[i]['mean_area']),\n",
    "            '连通性指数': float(connectivity_analysis[i]['connectivity_index']),\n",
    "            '生态功能指数': float(sum(ecological_assessment[i].values()) / len(ecological_assessment[i]))\n",
    "        } for i in range(len(class_names))\n",
    "    },\n",
    "    '景观指数': {\n",
    "        '多样性指数': {\n",
    "            'Shannon多样性指数': float(landscape_indices['基础指数']['Shannon多样性指数']),\n",
    "            'Simpson多样性指数': float(landscape_indices['基础指数']['Simpson多样性指数']),\n",
    "            '均匀度指数': float(landscape_indices['基础指数']['均匀度指数']),\n",
    "            '优势度指数': float(landscape_indices['基础指数']['优势度指数'])\n",
    "        },\n",
    "        '斑块指数': {\n",
    "            '总斑块数': int(landscape_indices['斑块指数']['总斑块数']),\n",
    "            '斑块密度': float(landscape_indices['斑块指数']['斑块密度']),\n",
    "            '平均斑块面积': float(landscape_indices['斑块指数']['平均斑块面积']),\n",
    "            '最大斑块比例': float(landscape_indices['斑块指数']['最大斑块比例'])\n",
    "        },\n",
    "        '连通性指数': {\n",
    "            '平均连通性指数': float(landscape_indices['连通性指数']['平均连通性指数']),\n",
    "            '平均聚合度指数': float(landscape_indices['连通性指数']['平均聚合度指数'])\n",
    "        },\n",
    "        '破碎化指数': {\n",
    "            '景观破碎化指数': float(landscape_indices['破碎化指数']['景观破碎化指数']),\n",
    "            '景观隔离指数': float(landscape_indices['破碎化指数']['景观隔离指数'])\n",
    "        },\n",
    "        '边缘指数': {\n",
    "            '总边缘长度': int(landscape_indices['边缘指数']['总边缘长度']),\n",
    "            '边缘密度': float(landscape_indices['边缘指数']['边缘密度']),\n",
    "            '平均核心区比例': float(landscape_indices['边缘指数']['平均核心区比例'])\n",
    "        }\n",
    "    },\n",
    "    '生态功能评估': {\n",
    "        '栖息地供给': float(ecosystem_services['栖息地供给']),\n",
    "        '景观连通性': float(ecosystem_services['景观连通性']),\n",
    "        '水质净化': float(ecosystem_services['水质净化']),\n",
    "        '气候调节': float(ecosystem_services['气候调节']),\n",
    "        '生物多样性维持': float(ecosystem_services['生物多样性维持']),\n",
    "        '综合功能指数': float(ecosystem_services['综合功能指数']),\n",
    "        '功能等级': function_level\n",
    "    },\n",
    "    '景观质量评价': {\n",
    "        '多样性': float(landscape_quality['多样性']),\n",
    "        '连通性': float(landscape_quality['连通性']),\n",
    "        '完整性': float(landscape_quality['完整性']),\n",
    "        '边缘质量': float(landscape_quality['边缘质量']),\n",
    "        '生态功能': float(landscape_quality['生态功能']),\n",
    "        '综合评分': float(landscape_quality['综合评分']),\n",
    "        '质量等级': quality_level\n",
    "    },\n",
    "    '主要发现': [],\n",
    "    '管理建议': []\n",
    "}\n",
    "\n",
    "# 基于分析结果生成主要发现\n",
    "findings = []\n",
    "suggestions = []\n",
    "\n",
    "# 多样性分析\n",
    "if basic_metrics['shannon_diversity'] > 1.5:\n",
    "    findings.append(f\"景观具有较高的多样性，Shannon指数为{basic_metrics['shannon_diversity']:.3f}\")\n",
    "elif basic_metrics['shannon_diversity'] < 1.0:\n",
    "    findings.append(f\"景观多样性较低，Shannon指数为{basic_metrics['shannon_diversity']:.3f}\")\n",
    "    suggestions.append(\"建议增加湿地植物群落类型，提高景观多样性\")\n",
    "\n",
    "# 连通性分析\n",
    "avg_connectivity = landscape_indices['连通性指数']['平均连通性指数']\n",
    "if avg_connectivity > 0.7:\n",
    "    findings.append(f\"景观连通性良好，平均连通性指数为{avg_connectivity:.3f}\")\n",
    "elif avg_connectivity < 0.5:\n",
    "    findings.append(f\"景观连通性较差，平均连通性指数为{avg_connectivity:.3f}\")\n",
    "    suggestions.append(\"建议建设生态廊道，提高景观连通性\")\n",
    "\n",
    "# 破碎化分析\n",
    "isolation_index = landscape_indices['破碎化指数']['景观隔离指数']\n",
    "if isolation_index > 0.6:\n",
    "    findings.append(f\"景观破碎化程度较高，隔离指数为{isolation_index:.3f}\")\n",
    "    suggestions.append(\"建议进行生态修复，减少景观破碎化\")\n",
    "\n",
    "# 生态功能分析\n",
    "eco_function = ecosystem_services['综合功能指数']\n",
    "if eco_function > 0.7:\n",
    "    findings.append(f\"湿地生态功能良好，综合功能指数为{eco_function:.3f}\")\n",
    "elif eco_function < 0.5:\n",
    "    findings.append(f\"湿地生态功能有待提升，综合功能指数为{eco_function:.3f}\")\n",
    "    suggestions.append(\"建议加强湿地保护与恢复，提升生态系统服务功能\")\n",
    "\n",
    "# 优势度分析\n",
    "if basic_metrics['dominance'] > 0.6:\n",
    "    findings.append(f\"景观中存在明显的优势类型，优势度指数为{basic_metrics['dominance']:.3f}\")\n",
    "    suggestions.append(\"建议增加其他湿地类型的面积，平衡景观组成\")\n",
    "\n",
    "landscape_report['主要发现'] = findings\n",
    "landscape_report['管理建议'] = suggestions\n",
    "\n",
    "# 保存报告\n",
    "with open(landscape_dir / 'landscape_analysis_report.json', 'w', encoding='utf-8') as f:\n",
    "    json.dump(landscape_report, f, indent=2, ensure_ascii=False)\n",
    "\n",
    "print(f\"景观分析报告已保存到: {landscape_dir / 'landscape_analysis_report.json'}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 打印最终综合报告\n",
    "print(\"\\n\" + \"=\"*80)\n",
    "print(\"湿地景观格局分析综合报告\")\n",
    "print(\"=\"*80)\n",
    "\n",
    "print(f\"\\n📍 基本信息:\")\n",
    "print(f\"   分析区域: {landscape_report['基本信息']['分析区域']}\")\n",
    "print(f\"   影像尺寸: {landscape_report['基本信息']['影像尺寸']}\")\n",
    "print(f\"   总面积: {landscape_report['基本信息']['总面积']:,} 像素\")\n",
    "print(f\"   类别数量: {landscape_report['基本信息']['类别数量']}\")\n",
    "\n",
    "print(f\"\\n🌿 类别组成:\")\n",
    "for class_name, stats in landscape_report['类别统计'].items():\n",
    "    print(f\"   {class_name}: {stats['面积比例']*100:.1f}% ({stats['面积_像素']:,} 像素, {stats['斑块数量']} 斑块)\")\n",
    "\n",
    "print(f\"\\n📊 主要景观指数:\")\n",
    "print(f\"   Shannon多样性指数: {landscape_report['景观指数']['多样性指数']['Shannon多样性指数']:.3f}\")\n",
    "print(f\"   平均连通性指数: {landscape_report['景观指数']['连通性指数']['平均连通性指数']:.3f}\")\n",
    "print(f\"   景观破碎化指数: {landscape_report['景观指数']['破碎化指数']['景观破碎化指数']:.3f}\")\n",
    "print(f\"   总斑块数: {landscape_report['景观指数']['斑块指数']['总斑块数']}\")\n",
    "print(f\"   边缘密度: {landscape_report['景观指数']['边缘指数']['边缘密度']:.4f}\")\n",
    "\n",
    "print(f\"\\n🌱 生态功能评估:\")\n",
    "print(f\"   综合功能指数: {landscape_report['生态功能评估']['综合功能指数']:.3f}\")\n",
    "print(f\"   功能等级: {landscape_report['生态功能评估']['功能等级']}\")\n",
    "print(f\"   栖息地供给: {landscape_report['生态功能评估']['栖息地供给']:.3f}\")\n",
    "print(f\"   水质净化: {landscape_report['生态功能评估']['水质净化']:.3f}\")\n",
    "print(f\"   生物多样性维持: {landscape_report['生态功能评估']['生物多样性维持']:.3f}\")\n",
    "\n",
    "print(f\"\\n🏆 景观质量评价:\")\n",
    "print(f\"   综合评分: {landscape_report['景观质量评价']['综合评分']:.3f}\")\n",
    "print(f\"   质量等级: {landscape_report['景观质量评价']['质量等级']}\")\n",
    "print(f\"   多样性: {landscape_report['景观质量评价']['多样性']:.3f}\")\n",
    "print(f\"   连通性: {landscape_report['景观质量评价']['连通性']:.3f}\")\n",
    "print(f\"   完整性: {landscape_report['景观质量评价']['完整性']:.3f}\")\n",
    "\n",
    "print(f\"\\n🔍 主要发现:\")\n",
    "for i, finding in enumerate(landscape_report['主要发现'], 1):\n",
    "    print(f\"   {i}. {finding}\")\n",
    "\n",
    "print(f\"\\n💡 管理建议:\")\n",
    "for i, suggestion in enumerate(landscape_report['管理建议'], 1):\n",
    "    print(f\"   {i}. {suggestion}\")\n",
    "\n",
    "print(f\"\\n📁 输出文件:\")\n",
    "print(f\"   - 景观分析概览图: {landscape_dir / 'landscape_analysis_overview.png'}\")\n",
    "print(f\"   - 详细分析报告: {landscape_dir / 'landscape_analysis_report.json'}\")\n",
    "\n",
    "print(\"\\n\" + \"=\"*80)\n",
    "print(\"湿地景观格局分析完成！\")\n",
    "print(\"=\"*80)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 总结\n",
    "\n",
    "本notebook完成了湿地高光谱分类结果的全面景观格局分析:\n",
    "\n",
    "### 🎯 主要成果:\n",
    "1. **多维景观指数**: 计算了30+个主要景观指数，全面评价景观格局\n",
    "2. **斑块特征分析**: 详细分析了各类别的斑块数量、面积、形状等特征\n",
    "3. **连通性评估**: 评价了景观的连通性和聚合度\n",
    "4. **破碎化分析**: 量化了景观破碎化程度和隔离状况\n",
    "5. **生态功能评估**: 评估了湿地的生态系统服务功能\n",
    "6. **综合质量评价**: 建立了景观质量评价体系\n",
    "\n",
    "### 📊 关键结果:\n",
    "- **景观多样性**: Shannon指数 = {:.3f}\n",
    "- **连通性水平**: 平均连通性指数 = {:.3f} \n",
    "- **破碎化程度**: 景观隔离指数 = {:.3f}\n",
    "- **生态功能**: 综合功能指数 = {:.3f} ({})\n",
    "- **景观质量**: 综合评分 = {:.3f} ({})\n",
    "\n",
    "### 🌟 重要发现:\n",
    "{}个主要发现，{}条管理建议，为湿地保护与管理提供科学依据。\n",
    "\n",
    "### 🚀 应用价值:\n",
    "1. **生态保护**: 为湿地保护规划提供科学依据\n",
    "2. **景观优化**: 指导生态修复和景观改善\n",
    "3. **功能提升**: 优化生态系统服务功能\n",
    "4. **管理决策**: 支持湿地管理政策制定\n",
    "\n",
    "景观格局分析为理解湿地生态系统的空间结构、生态过程和功能特征提供了重要insights，对湿地可持续管理具有重要意义。\n",
    "\".format(\n",
    "    landscape_report['景观指数']['多样性指数']['Shannon多样性指数'],\n",
    "    landscape_report['景观指数']['连通性指数']['平均连通性指数'],\n",
    "    landscape_report['景观指数']['破碎化指数']['景观隔离指数'],\n",
    "    landscape_report['生态功能评估']['综合功能指数'],\n",
    "    landscape_report['生态功能评估']['功能等级'],\n",
    "    landscape_report['景观质量评价']['综合评分'],\n",
    "    landscape_report['景观质量评价']['质量等级'],\n",
    "    len(landscape_report['主要发现']),\n",
    "    len(landscape_report['管理建议'])\n",
    ")"
   ]
  }
 ],\n \"metadata\": {\n,
  \"kernelspec\": {\n,
   \"display_name\": \"Python 3\",\n,
   \"language\": \"python\",\n,
   \"name\": \"python3\"\n,
  },\n,
  \"language_info\": {\n,
   \"codemirror_mode\": {\n,
    \"name\": \"ipython\",\n,
    \"version\": 3\n,
   },\n,
   \"file_extension\": \".py\",\n,
   \"mimetype\": \"text/x-python\",\n,
   \"name\": \"python\",\n,
   \"nbconvert_exporter\": \"python\",\n,
   \"pygments_lexer\": \"ipython3\",\n,
   \"version\": \"3.9.0\"\n,
  }\n,
 },\n,
 \"nbformat\": 4,\n,
 \"nbformat_minor\": 4\n,
}